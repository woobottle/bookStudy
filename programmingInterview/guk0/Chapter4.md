# chapter 4. 프로그래밍 문제 접근법

## 절차
<br/>  

### 문제
- 실전에 직접 적용할 수 있는 코드가 나올 가능성은 희박함. 대신 특별한 트릭이나 언어에서 자주 쓰이지 않는 기능들을 필요로 하는 문제가 자주 출제.
- ex) 비교 연산자를 전혀 사용하지 않고 두 정수가 같은지 판단? (비트 연산 활용)
  ```javascript
    // 비교연산
       x == y 
       
    // 비트연산   
      !(x ^ y)

  ```
  - xor 연산자 ^를 사용.

### 소통이 핵심이다.
 - 면접시 최고의 코드를 만들 수 있어야한다. 지저분하게 짠다면 이 사람은 원래 지저분하게 짜는구나라고 판단할 수 밖에 없음.
 - 면접관이 지원자가 어떻게 문제를 푸는지 지켜본다면, 면접관에게 질문을 통해 힌트를 얻을 수 있다. 힌트를 얻은 뒤 문제를 푸는 과정에서 자신의 사고력과 문제해결 능력을 보여주는 것도 중요하다.
 - 아는 문제라도 각 단계에서 사고 과정을 정리해서 대답해야 한다. 정답을 외워서 맞추는 것이 아닌 개념을 이해하고 있는가가 중요하다.
 - 문제를 푸는 과정에서 자신의 프로그래밍에 관한 전반적인 지식을 어필할 기회가 있다면 활용하는 것이 중요하다.  

<br/>

## 문제 해결
코드 먼저 작성하지 말고 문제를 완벽하게 이해 한 후 구체적인 예로 시도해보고, 해결과정을 알고리즘으로 일반화. 그 알고리즘을 설명한 뒤 코드를 작성한다.  
<br/>

### 문제 해결을 위한 단계
 - 문제를 확실히 이해한다.
   - 문제가 되는 부분을 찾아내고 이해할 수 있는지 면접관이 일부러 정보를 숨기는 경우가 있음. 이럴 땐 주저하지 말고 질문. 
   - 제대로 이해하기 전 문제부터 푸는 행위는 지양.
 - 간단한 예를 시도해본다.
   - 정확히 문제를 이해하였는지 검증하는 과정.
 - 문제 풀이에 사용할 알고리즘과 자료구조에 초점을 맞춘다.
   - 이 단계에서는 면접관과의 의사소통이 중요.
   - 사고의 과정을 면접관에게 계속 설명. ex) "값을 배열에 저장하고 정렬을 할 수 있을지 생각해보고 있는데, 배열에 있는 원소는 값을 기준으로 빨리 찾아낼 수가 없기 때문에 별로 좋지 않을 것 같네요"
 - 알고리즘과 구현 방법을 알아내고 나면 면접관에게 풀이를 설명한다.
 - 코딩을 할 때도 뭘 하고 있는지 설명한다.
   - ex) 여기에서는 배열을 전부 0으로 초기화합니다.
 - 필요하다면 질문을 한다.
   - 풀이 방법을 질문하는 것이 아닌 ex) "지역화된 날짜 시각을 출력할 때 어떤 형식 문자열을 쓰는지 알 수 있을까요?
 - 코드를 완성하고 나면 바로 몇 가지 예를 시도해보고 맞는지 확인한다.
 - 모든 오류 및 특수 상황, 특히 경계 조건을 확인한다.

<br/>

### 막히는 경우
 - 예를 다시 따져본다.
 - 다른 자료구조를 시도해본다.
 - 언어에서 그리 많이 쓰이지 않는 기능 또는 고급 기능을 고려해보자.

<br/><br/>

## 풀이 분석
  풀이 후 면접관이 어떤 방식이 효율적인지 질문하는 경우가 있다. 이럴 때는 빅 오 분석법을 통해 알고리즘의 효율성을 따져보자.

<br/>

### 빅 오 분석
입력 값의 크기(개수)를 n개에 대한 **연산 횟수**를 n의 식으로 표현.

 - 입력 값이 무엇인지 확인하고 어떤 값을 n으로 놓아야 할지 결정한다.
 - 알고리즘에서 수행해야할 연산 횟수를 n의 식으로 표현한다.
 - 차수가 제일 높은 항만 남긴다.
 - 모든 상수 인수를 없앤다.
 ```js
  // 최고 차항으로만 표기. 최고차항의 계수는 버림.   
  
  n^2 + n = O(n^2)  
  2n + 2 = O(n)
```
 - 종류(제일 빠른 순)
   - O(1)
   - O(log n)
     - 로그 알고리즘
   - O(n)
   - O(nlog n)
   - O(n^c)
   - O(c^n)
     - 지수 알고리즘
   - O(n!)
     - 팩토리얼 알고리즘. 가장 느림. 

<br/>

 - 음이 아닌 수가 저장된 배열에서 최댓값을 구하는 함수.
 ```c++
 # O(n)

int CompareToMax(int array[], int n) {
  int curMax, i;

  if (n <= 0) 
    return -1;
  
  currMax = array[0];

  for (i = 1; i < n; i++) {
    if (array[i] > currMax) {
      currMax = array[i];
    }
  }
  return curMax;
}
```

```c++
# O(n^2)

int CompareToAll(int array[], int n) {
  int i, j;
  bool isMax;

  if (n <= 0) 
    return -1;

  for (i = n - 1; i > 0; i--) {
    isMax = true;
    for (j = 0; j < n, j++){
      if (array[j] > array[i])
        isMax = false
    }
    if (isMax) break;
  }
  return array[i];
}
```

<br/>

### 메모리 용량 분석
 - 빅 o 분석은 시간복잡도(Time Complexity)와 공간 복잡도 (Memory Complexity)로 나뉘는데 공간복잡도는 메모리 성능이 좋아지면서 시간복잡도에 더 관심을 기울이는 편.

 - 빅O 분석과 유사하게 입력 크기 n의 식으로 표현하는 접근법을 사용. 입력 크기에 따라 필요한 저장 공간을 따져보면 됨.

