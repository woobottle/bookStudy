- 정렬 관련 문제는 알고리즘의 복잡도에서 메모리 사용에 이르기까지 다양한 사안을 알아보기 좋다는 장점 때문에 면접관이 좋아하는 문제이기도 하다.

## 정렬 알고리즘

- 고려해야할 사항

  - 정렬할 데이터의 양
    - 데이터가 많을 때는 어떤 알고리즘을 쓰는지에 따라 실행 시간이 크게 달라질 수 있다. 가끔씩 아주 많은 양의 데이터를 처리해야 하는 상황도 염두에 두자
  - 데이터와 메모리
    - 대부분의 알고리즘은 처리할 데이터가 메모리에 있을 때만 효율적으로 돌아간다. 메모리에 다 올릴 수 없으면 잘라서 정렬하고 합치자.
  - 데이터가 정렬된 정도
    - 새 데이터를 추가할 때 정렬되지 않은 목록에 대해서만 효율이 나쁜 알고리즘도 있다.
  - 필요한 추가 메모리의 양
    - 메모리가 빠듯할 때는 효율보다는 추가 메모리를 적게 쓰는 점을 고려하여 알고리즘을 골라야 할 수도 있다.
  - 상대 위치 보존 여부
    - 아무 상관없는 원소들의 상대적인 위치가 그대로 유지되는 알고리즘을 stable 알고리즘이라 부른다. 보통 stable한 쪽이 더 나은 편이긴 하지만, 성능을 위해 안정성을 희생해도 괜찮은 경우가 있다.

- 정렬 순서를 결정하는 값을 key라고 부른다.

- 대부분의 정렬 알고리즘은 키의 대소 유무를 비교 알고리즘을 바탕으로 돌아간다. 비교 알고리즘 중에 최악 조건의 실행 시간이 O(nlog(n))보다 빠른 것은 없다.

## 선택 정렬 (Selection Sort)

- 첫 번째 원소에서 시작하여 배열 전체를 훑으면서 가장 작은 키를 가지는 원소와 첫 번째 원소를 맞바꾼다.

- 최선, 평균, 최악 모두 O(n^2)

- 원소를 움직이는 게 비교 작업에 비해 느리다면 다른 알고리즘보다 좋을 수 있다. 효율은 최적화 기준에 따라 달라질 수 있다.

- 선택 정렬은 제자리 정렬 알고리즘이며, 일반적인 선택 정렬 코드는 unstable하다.

## 삽입 정렬 (Insertion Sort)

- 정렬된 리스트에 대해선 O(n)이지만, 평균과 최악은 O(n^2)이기 때문에 무작위로 정렬된 많은 데이터를 처리하기에는 좋은 알고리즘은 아니다.

- 안정적인 제자리 정렬 알고리즘으로 구현 가능.

- 소량의 데이터 집합을 처리할 때 강점을 발휘하기 때문에 다른 정렬 알고리즘을 만드는 기본 단위로 많이 쓰임.

## 퀵 정렬 (Quicksort)

- 집합 내에서 한 pivot value를 고른 다음 이를 기준으로 두 개의 부분집합을 나눈다. 한 쪽에는 pivot value보다 작은 값, 다른 쪽에는 큰 값만 넣고 이 작업을 재귀적으로 적용하면 정렬된 데이터 집합이 만들어진다.

- 피벗 값을 잘 골랐을 경우 복잡도는 O(nlog(n))이고 그렇지 않을 경우에는 선택, 삽입 정렬과 같은 속도인 O(n^2)이다. 평균은 O(nlog(n))이다.

- 퀵 정렬 구현 방법은 대부분 unstable하다.

## 합치기 정렬 (Merge Sort)

- 둘 이상의 부분집합으로 가르고 정렬한 다음 다시 합치는 방식

- 분할정복형 알고리즘이다.

- 어떤 정해진 크기보다 작은 부분배열을 다른 알고리즘으로 정렬하는 방식은 Hybrid Merge Sort라고 부른다.

```java
if (data.length < 2){
  return;
})

if (data.length < 10){
  insertionSort( data );
  return;
})
```

- 삽입 정렬은 합치기 정렬에 비해 대체로 오버헤드도 적고 데이터 집합이 아주 작을 때 더 빠른 편이기 때문에 위와 같이 최적화 방법을 쓰는 경우가 흔하다.

- 데이터 집합이 메모리에 한 번에 올리기 너무 너무 클 때 쓰기 좋은 방법이다.

- 최고, 최저, 평균 실행시간 모두 O(nlog(n))이기 때문에 정렬 시간의 상한을 철저하게 지켜야 할 때 매우 좋다.

- O(n) 수준의 메모리가 추가로 필요하다는 단점도 존재.

- 일반적인 구현법은 stable이지만 In-place sort(제자리 정렬 알고리즘)은 아니다.

## 문제

- 안정적인 정렬과 불안정한 정렬은 큰 레코드나 객체의 한 부분을 키로 잡아서 쓸 때만 그 차이점이 나타난다. (단순히 int 값만 정렬하는 거라면 구분할 수 없을 것)
