- 트리는 재귀 호출과 실행 시간 분석에 관한 지식을 테스트하기에 안성맞춤.

## 트리

- 객체지향 언어에서는 보통 노드의 공통적인 부분을 하나의 클래스로 정의,  
  노드에 들어가는 데이터를 위해 서브클래스를 만들어 사용.

- 노드에서 참조하는 모든 노드를 private로 선언,  
  배열을 건드리기 위한 메서드만 공개.

- 최상위 노드르 Root라 부른다.  
  Root는 다른 모든 노드로 가는 경로가 반드시 존재해야만 하는 유일한 노드.

- 기본 용어
  - Parent
  - Child
  - Descendant(자손): 특정 노드로부터 자식 노드로 이어지는 경로를 따라 도달할 수 있는 모든 노드
  - Leaves(잎): 자식이 없는 노드

## 이진 트리

![이진트리](https://user-images.githubusercontent.com/72548112/139967770-314fcf2e-05bd-4657-adab-553528c669e3.png)

- 한 노드에 자식이 최대 두 개까지만 있을 수 있으며, 각각 왼쪽 자식과 오른쪽 자식이라고 부른다.

## Binary Search Tree (이진 검색 트리)

- 노드의 왼쪽 자식의 값이 반드시 자신의 값 이하이며, 오른쪽 자식의 값은 자신의 값 이상.

- 트리에 있는 특정 노드의 위치를 알아내는 연산(LookUp)을 빠르고 간단하게 처리할 수 있다.

- 한 번에 절반씩의 노드를 검색 대상에서 제외할 수 있기 때문에 빠르다.  
  Balanced 이진 검색 트리에서는 LookUp이 O(log(n)) 연산이다.  
  그렇지 않은 경우엔 O(n) 연산이 될 수도 있다.

- 트리 연산 중 상당수는 재귀적으로 구현할 수 있다.

## Heap

- 노드의 각 자식의 값은 자신의 값 이하여야 한다.  
  루트 노드의 값이 가장 큰 값.

- 최대값은 상수 시간, 삽입과 삭제는 O(log(n)) 연산, LookUp은 O(n) 연산.

## 일반적인 검색 방법

- BST나 Heap이 아닌 가계도나 회사의 직위체계 등을 나타내는 트리에서 데이터를 가져오려면 다른 기법을 사용해야 한다.

### Breadth-First Search (너비 우선 탐색)

- 루트에서 시작하여 층마다 왼쪽에서 오른쪽으로 훑어나가는 식.  
  노드를 찾는데 O(n) 시간이기 때문에 큰 트리에서는 지양.  
  층을 검색할때 그 층에 있는 모든 노드의 자식들을 저장해둬야 하기 때문에 메모리도 많이 사용.

### Depth-First Search (깊이 우선 탐색)

- 원하는 노드를 찾을때까지 한 가지를 따라 쭉 내려가는 방식  
  더 이상 검색을 진행할 수 없으면 확인해보지 않은 자식이 있는 가장 가까운 조상 노드로 돌아가 검색 진행.

- DFS는 BFS에 비해 메모리 요구량이 훨씬 적다.

## Traversal (종주)

- Preorder 종주  
  '노드 자체 -> 왼쪽 자손 -> 오른쪽 자손' 순으로 처리

- Inorder 종주  
  '왼쪽 자손 -> 노드 자체 -> 오른쪽 자손' 순으로 처리

- Postorder 종주  
  '왼쪽 자손 -> 오른쪽 자손 -> 노드 자체' 순으로 처리

```python
def order(root):
  if root == null return
  arr.append(root) # append 순서에 따라 pre / in / post 인지 판단. (해당 코드는 pre)
  order(root.getLeft())
  order(root.getRight())

```

- 종주를 구현하는 가장 간단한 방법은 재귀 호출을 이용하는 방법.

## 그래프

- 트리와 달리 한 노드에 부모가 여럿 있을 수 있어서 루프(사이클)가 만들어질 수 있다.

- 노드 자체가 아닌 노드 사이의 링크에도 가중치가 있을 수 있다.  
  이렇게 별도의 정보를 담을 수 있는 링크를 Edge라고 부른다.  
  단방향 Edge가 들어있는 그래프는 Directed Graph (방향성 그래프)  
  양방향 Edge만 들어있는 그래프는 Undirected Graph (무방향성 그래프) 라고 부른다.  
  ![Edge graph](https://user-images.githubusercontent.com/72548112/139976436-cf85998b-2081-4638-9ce9-fa12a5b167cc.png)

- Adjacency List (인접 리스트)는 한 노드에 연결되는 Edge 개수에 제한이 없기 때문에 보통 동적인 자료구조다.  
  => 어떤 노드와 같은 Edge를 공유하는 다른 노드에 대한 레퍼런스의 리스트

- Adjacency Matrix (인접 행렬)은 노드 개수만큼의 차원 수로 만들어진 정사각 행렬 형태의 자료구조이다.  
  => i 노드에서 j 노드로 이어지는 Edge의 개수를 나타냄.

## 트리 및 그래프 문제
