# 코딩 문제

- 면접에서 나오는 문제는 원래 어렵다. 답이 바로 보이지 않는 상황에서 문제를 어떤 식으로 해결하는지를 살펴보기 위해 내는 문제도 있다.

## 절차

- 지원자가 코딩을 할 수 있는지, 실력이 어느 정도 되는지를 가늠하는 것.

## 시나리오

- 특정 제약 조건 내에서 주어진 일을 처리하는 능력도 매우 중요한 역량 가운데 하나다.

## 어떤 언어를 사용할 것인가

- 자신이 사용할 모든 언어의 사용법 및 문법을 제대로 숙지해야만 한다.

## 소통이 핵심이다

- 지원자가 만든 코드 중에 직접 본인 눈으로 확인해볼 수 있는 코드는 면접 시에 작성한 코드뿐이기에 면접 시에 최고의 코드를 만들 수 있어야 한다.
- 면접관이 정말로 원하는 것은 지원자가 문제를 푸는 각 단계들을 어떻게 진행하는지 보는 것이다.
- 계속해서 설명을 하자. 항상 무슨 일을 하고 있는지 설명해야 한다.

## 문제 해결

- 문제를 풀기 시작하면 무작정 코드부터 작성하는 일은 금물이다. 이는 가장 마지막에 할 일이다.

## 기본 단계

1. 문제를 확실히 이해한다.  
   문제를 이해하지 못하면 자기 능력을 보여줄 수 없음은 당연하다.

2. 일단 문제를 이해하고 나면 간단한 예를 시도해본다.

3. 문제 풀이에 사용할 알고리즘과 자료구조에 초점을 맞춘다.  
   생각할 시간이 걸리는 것은 당연하다. 그러나 계속해서 면접관에게 지금 무엇을 하고 있는지를 얘기하자.

4. 알고리즘과 구현 방법을 알아내고 나면 면접관에게 풀이를 설명한다.

5. 코딩을 할 때도 뭘 하고 있는지 설명한다.

6. 필요하다면 질문을 한다.  
   레퍼런스에서 찾을 수 있을 법한 내용이라면 질문을 해도 큰 감점 사유가 되진 않는다.

7. 코드를 완성하고 나면 바로 몇 가지 예를 시도해보고 맞는지 확인한다.  
   자기가 만든 코드가 적어도 시도해본 예에 대해서는 제대로 작동한다는 것을 분명하게 보여줄 수 있다.

8. 모든 오류 및 특수 상황, 특히 경계 조건을 확인한다.  
   오류 및 특수 상황을 제대로 커버하면 면접관에게도 좋은 인상을 남길 수 있고 문제를 올바르게 푸는 데도 도움이 된다.

- 코드가 제대로 만들어졌다는 판단이 들면 "실행 시간", "또 다른 구현 방법", "복잡도" 등에 초점을 맞춘 질문을 던질 수도 있다.

## 문제를 풀다가 막히는 경우

- 계속해서 문제에 대해 관심을 가지고 문제를 풀려고 시도하는 모습을 보이자.

- 예를 다시 따져본다.  
  특정 예를 다시 따져보며, 더 나아가 일반적인 예로 확장해보자.

- 다른 자료구조를 시도해본다.  
  올바른 자료구조를 사용하는 것만으로 문제 풀이가 훨씬 수월해지는 일도 흔하다.

- 언어에서 그리 많이 쓰이지 않는 기능 또는 고급 기능을 고려해보자.

- 가끔씩 큰 그림을 다시 한 번 생각해보고 더 나은 접근법이 없는지 알아보자.

- 코드가 30줄을 넘기는 경우도 드문 편이고, 50줄을 넘기는 일은 거의 없다고 봐도 된다. 코드가 너무 길어지고 있다면 뭔가 잘못됐다는 징조일 수 있다.

## 풀이 분석

- 구현한 풀이 방법과 다른 풀이 방법을 제시하고 그 둘의 장단점을 비교한다거나 어떤 상황에서 어떤 구현 방법이 더 유리할지를 물어보는 경우도 많다.

- 메모리 또는 공간 사용에 관한 질문도 자주 나오는 편이다.

- 빅 오 분석법을 제대로 이해하고 있다면 면접관에서 좋은 인상을 남기는 데 크게 도움이 된다.

## 빅 오 분석 (big-O analysis)

- 일반적으로 서로 다른 알고리즘의 상대적인 성능 차이는 입력 크기가 커질수록 두드러진다.

- 이럴 때 빅 오 분석법을 활용하면 서로 다른 알고리즘의 상대적인 성능을 예측하고 비교해볼 수 있다.

## 빅 오 분석법의 원리

- 입력 값의 크기(개수)를 n개로 가정하여 연산 횟수를 n의 식으로 표현해야 한다.

- 빅 오 분석을 할 때는 n이 매우 큰 경우의 실행 시간인 점근적인 실행 시간만 따진다. 그렇기에 최고차항만 남기고 다른 항은 다 무시한다.

## 최선, 평균, 최악 케이스

- 면접관에게 어떤 시나리오에 가장 중점을 둬야 할지 물어보는 것도 한 방법이다.

## 최적화와 빅 오 분석법

- 알고리즘을 최적화한다고 해서 항상 전체 실행 시간이 빨라지진 않는다.

- 가장 큰 숫자를 찾는 문제에서 비교하는 대상과 전체 배열을 비교하든, 뒤에 있는 배열만 비교하든 실행 시간은 여전히 동일할 수 있다.

- 입력 개수가 많아지면 잉런 식으로 알고리즘을 최적화한다고 해서 실행 시간이 별로 달라질 것도 없다는 뜻이다.

## 빅 오 분석법을 적용하는 방법

1. 입력 값이 무엇인지 확인하고 어떤 것을 n으로 놓아야 할지 결정한다.
2. 알고리즘에서 수행해야 할 연산 횟수를 n의 식으로 표현한다.
3. 차수가 제일 높은 항만 남긴다.
4. 모든 상수 인수를 없앤다.

## 어떤 알고리즘이 나을까?

1. O(log n)  
   로그 알고리즘
2. O(n)  
   선형 알고리즘
3. O(n log n)  
   준선형 알고리즘
4. O(n^c)  
   다항식 알고리즘
5. O(c^n)  
   지수 알고리즘
6. O(n!)  
   팩토리얼 알고리즘

- 준선형 이하의 알고리즘을 찾으면 애플리케이션 성능을 크게 향상시킬 수 있다.

## 메모리 용량 분석

- 임베디드 시스템처럼 제약이 많은 환경에선 실행 시간 못지않게 메모리 용량도 중요하다.

- 알고리즘의 메모리 용량  
  빅 오와 유사하게 입력 크기(n)에 따라 필요한 연산 횟수 대신 각 항목에 대해 필요한 저장 공간을 따지면 된다.

- 구현 방법의 메모리 사용량  
  이런 질문에서 면접관이 파악하고 싶은 건 얼마나 정확하게 맞추는지가 아니라, 실제 자료구조가 어떻게 구현되는지 제대로 이해하고 있는가 하는 것이다.

- 메모리 용량 문제를 얘기할 때는 항상 면접관에게 상충적인 부분에 대해서도 언급할 필요가 있다.

## 요약

- 정확하고 완전한 답을 하기 위해 최선을 다해야 한다.

- 면접관에게 힌트를 받아야 할 수도 있는지, 너무 부담을 가질 필요는 없다.

- 자신이 사용할 언어를 잘 선택하고 꼼꼼히 익혀두자

- 문제를 풀 때는 면접관과 의사소통을 최대한 활발하게 하자.

- 문제 이해 => 몇 가지 예시로 재확인 => 적절한 알고리즘 선택 및 예제 확인 => 특별 케이스 고려 => 다른 예를 시도하거나 다른 알고리즘 적용 시도 => 언어 자체의 특수 기능이나 고급 기능도 고려.

- 빅 오 실행 시간 분석법을 적용하여 성능에 대한 설명 with 알고리즘의 메모리 용량.

## 스터디

- HD 데이터 메모리 위치가 중요할 수 있다.
  자주 쓰이는 애들은 인접한 위치에 있으면 더 적게 도니깐 유용하다.

하지만 RAM은 그렇지 않다. 바로 접근할 수 있기에 변함없을 것 같지만 유효하다고 설명되어있다.

연결 리스트에서는 주소값을 가지고 있으니 갔다가 가는건데 결국엔 첫번째 위치 + 자료형 x 인덱스 로 바로 계산된 주소가 나오니깐 영향이 있는 것 같다.

https://bluejake.tistory.com/44

- RAM 공간이 모자르니 메모리가 없는 곳에 가서 HD같은 디스크에서 ram 역할을 하는 메모리를 가상으로 할당하는 것인데 쨌든 HD에 있는 것이니 불러오는 속도가 늦을거다..

- 결국에는 가상 메모리를 쓰고 있다면 접근하는게 겁나 느리다.

- 포인터에 관련해서는 이상한 문제를 해결해봐야 한다. 한번 해보면 이해가 빠를 듯.

- 포인터로 쓸때 \*으로 쓴다.

- 사실 이런 것들은 홍정모씨의 강의를 보면 된다.
