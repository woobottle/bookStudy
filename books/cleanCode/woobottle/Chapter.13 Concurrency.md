# 13. Concurrency

여러 스레드를 동시에 돌리는 이유를 알려주는 장
### 동시성이 필요한 이유?
동시성은 
* 결합을 없애는 전략
* 무엇과 언제를 분리하는 전략

예시. 서블릿 모델<br>
서블릿은 웹 혹은 EJB 컨테이너 아래에서 돌아간다. 이들 컨테이너는 동시성을 관리한다.
웹 요청이 들어오면 웹 서버는 비동기식으로 서블릿을 실행한다.
개발자는 요청을 개별적으로 처리하는 데에만 신경을 쓰며 모든 웹 요청을 관리할 필요가 없다.<br>
각 서블릿 스레드는 자신만의 세상에서 돌아간다

동시에 처리함으로써 처리량을 늘릴수 있다. 

##### 미신과 오해

* 동시성은 항상 성능을 높여준다
  * 여러 스레드가 프로세스를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 많을때만 성능이 올라감
* 동시성을 구현해도 설계는 변하지 않는다
  * 설계는 많이 달라진다.
* 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
  * 동시성은 컨테이너에서 관리를 하긴 하지만 알아야 한다.

알고 있어야할 사항들
* 동시성은 부하를 일으킨다. 코드도 더 짜야한다.
* 동시성은 복잡하다.
* 동시성 버그는 재현하기 어렵다.
* 근본적인 디자인 개편이 필요하다

### 난관

같은 코드의 실행결과가 동시성 이슈로 인해 달라질 수 있다
```java
public class ClassWithThreadingProblem {
  private int lastIdUsed;

  public ClassWithThreadingProblem(int lastIdUsed) {
    this.lastIdUsed = lastIdUsed;
  }

  public int getNextId() {
    return ++lastIdUsed;
  }
}

public static void main(String args[]) {
  final ClassWithThreadingProblem classWithThreadingProblem = new ClassWithThreadingProblem(42);

  Runnable runnable = new Runnable() {
    public void run() {
      classWithThreadingProblem.getNextId();
    }
  }

  Thread t1 = new Thread(runnable);
  Thread t2 = new Thread(runnable);
  t1.start();
  t2.start();
}
```

두 스레드가 같은 변수를 참조하기 때문에 아래와 같은 결과가 발생 

**동시성 / 병렬성**   
동시성은 여러 스레드가 스케줄링에 따라 자원을 점유 할때마다 돌기 때문에 발생하는 것, 점유 순서, 점유 시간이 스케줄링에 따라 다름


* t1이 43, t2가 44, lastIdUsed는 44
* t1이 44, t2가 43, lastIdUsed는 44
* t1이 43, t2가 43, lastIdUsed는 43

getNextId 메서드는 8개의 자바 바이트코드로 변환되며, 이를 두 스레드에서 실행하게 되면 12870개의 경우의 수가 발생

### 동시성 방어 원칙

##### 단일 책임 원칙
SRP => 메서드/클래스/컴포넌트를 변경할 이유는 하나여야 한다.<br>
동시성은 복잡해서 무조건 하나로 분리해야 한다.
동시성 고려시 고려해야 할 사항들

* 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다
* 동시성 코드에는 다른 문제보다 훨씬 어렵다
* 동시성 코드의  실패이유는 너무나 많다.

##### 따름 정리: 자료 범위를 제한하라
코드 내 임계 영역<sup>[[1](#1-임계영역)]</sup>을 synchronized 키워드로 보호한다.
임계 영역이 많을수록 아래의 문제가 발생할 수 있다

```java
synchronized(락-객체) {
  // 임계 영역 (Thread 동시 접근이 불가능한 처리)
}

// 같은 락-객체를 사용하는 여러 synchronized 블록은 한 곳만 thread가 진입해도 다른 thread들은 접근이 안된다.
```
공유 자원 

* 보호할 임계영역을 빼먹는다. 
* 모든 임계영역을 확인해야 한다. 매번 수고가 들어간다
* 버그가 더욱 찾기 어려워진다

##### 따름 정리: 자료 사본을 사용하라
처음부터 공유하지 말자.
1. 객체를 복사해 읽기 전용으로 사용
2. 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 져오는 방법

##### 따름 정리: 스레드는 가능한 독립적으로 구현하라
다른 스레드와 자료를 공유 하지 않게 한다.
각 스레드는 클라이언트 요청 하나를 처리한다.


### 라이브러리를 이해하라
자바 5로 스레드 구현할때 고려 사항들 
* 스레드 환경에 안전한 컬렉션 사용
* executor 프레임워크 사용
* 스레드가 차단되지 않는 방법을 사용
* 일부 클래스 라이브러리는 스레드에 안전하지가 않음


##### 스레드 환경에 안전한 컬렉션 

|name|description|
|--|--|
|ReentrantLock|한 메서드에서 잠그고 다른 메서드에서 푸는 락|
|Semaphore| 전형적인 세마포어(갯수를 셀 수 있는 lock)|
|CountDownLatch|지정한 수만큼 이벤트가 발생하고 나서야 대기중인 스레드를 모두 해체하는 락|

* 언어가 제공하는 클래스를 검토해보자

### 실행 모델을 이해하라

|name|description|
|--|--|
|한정된 자원(Bound Resource)|다중 스레드 환경에서 사용하는 자원, 크기나 숫자가 제한적. 데이터 베이스 연결, 길이가 일정한 읽기/쓰기 버퍼|
|상호 배제(Mutual Exclusion)|한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우|
|기아(Starvation)|한 스레드 혹은 스레드의 그룹이 긴 시간 동안 작업을 수행할 수 없게 된다. 항상 짧은 스레드에게 우선권을 주면 긴 스레드는 계속 작업을 못하게 된다.|
|데드락(Deadlock)|여러 스레드가 서로가 끝나기를 기다린다. 각 스레드는 필요한 자원을 점유하고 있으며 필요한 자원을 얻지 못하게 되면 누구도 작업을 끝내지 못하게 된다.|
|라이브락(Livelock)|스레드들이 서로 작업을 수행하려는 중 다른 스레드가 작업중인 것을 인지하고 서로 양보한다.  이것때문에 굉장히 오랫동안 혹은 영원히 진행을 못한다.|


##### 생산자-소비자
스레드를 생산자, 소비자로 구분하고   
생산자는 정보를 생성해 버퍼(buffer)나 대기열(queue)에 넣는다  
생산자는 대기열에 정보를 채운 다음 소비자 스레드에게 '정보를 채웠다'고 시그널을 보낸다  
소비자는 시그널을 받고 대기열에서 정보를 읽어 들인후 '대기열에 빈 공간이 있다'는 시그널을 보낸다.  
잘못하면 둘다 시그널만 기다리고 있는 상황이 존재할 수 있다.

##### 읽기-쓰기
읽는 스레드와 쓰는 스레드 간에 적절한 우선순위의 조정이 필요하다.<br>
처리량을 위해 읽는 스레드가 우선권을 가지게 하면 쓰는 스레드는 기아 상태에 빠지게 될 수 있다. <br>
반대의 경우에는 버퍼나 큐가 정보로 가득차게 된다.<br>
따라서 적절한 우선순위의 교차가 필요하다

##### 식사하는 철학자들 
여러 프로세스가 자원을 얻으려 경쟁한다. 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪는다<br>
대다수 다중 스레드 문제는 위의 세 범주안에 포함된다.
연습하고 그 해법을 익히자

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

메서드 사이에 의존성이 존재하면 동시성 코드는 버그를 발생시킬 수 있다.
java에서는 synchronized 개념을 지원하긴 하지만 위의 상황은 좋지 않다.
다음의 세가지 방법을 고려해보자

* 클라이언트에서 잠금
  * 클라이언트에서 처음 메서드를 부르기 이전부터 마지막 메서드를 호출할 때까지 서버를 잠근다.
* 서버에서 잠금
  * 서버가 스스로를 잠그고 이를 풀 수 있는 메서드를 클라이언트에서 호출하게 한다.
* 연결 서버
  * 잠금을 수행하는 중계자를 작성, 서버에서 잠금 방식과 유사 그러나 실제 서버를 잠그지는 않는다.

### 동기화하는 부분을 작게 만들어라
Synchronized를 이용한 락은 스레드에 비싼 비용을 발생시킨다. 그래서 가능한 한 작게 만들어야 한다.
임계영역은 보호되어야 한다.

### 올바른 종료 코드는 구현하기 어렵다
잠시 돌다 종료되는 시스템과 영구적으로 돌아가는 시스템은 다르다<br>
깔끔하게 종료되는 시스템은 구현하기 어렵다. 데드락 상황이 발생할 수 있다.<br>

데드락에 걸린 자식 스레드를 기다리는 부모 스레드는 영영 종료되지 못한다.
생산자/소비자 관계의 자식스레드가 존재하는 경우 부모 스레드는 종료 시그널을 보냈지만 
생산자 스레드는 종료되었지만 소비자 스레드는 생산자 스레드의 신호를 계속 기다리고 있으므로 데드락에 빠진다.


### 스레드 코드 테스트하기
추천: 문제를 노출하는 테스트 케이스를 작성하라. 다양한 경우의 수를 적용해야 한다.
테스트가 실패하면 필히 원인을 찾고 해결해야 한다.

고려해야할 사항들
* 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
* 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
* 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
* 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
* 프로세서 수보다 많은 스레드를 돌려라
* 다른 플랫폼에서 돌려보라
* 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라


### 결론 
다중 스레드 코드는 올바로 구현하기 어렵다.
SRP를 준수한다. POJO를 사용해 스레드를 아는 코드와 스레드를 모르는 코드를 분리한다.
동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다.
사용하는 라이브러리와 기본 알고리즘을 이해한다.
보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.
문제가 발생하면 일회성으로 간주하지 않고 계속 테스트 해가면서 해결한다


<hr>

##### 1. 임계영역
<https://ko.m.wikipedia.org/wiki/%EC%9E%84%EA%B3%84_%EA%B5%AC%EC%97%AD> <br>
=> 둘 이상의 스레드가 접근해서는 안되는 공유 자원을 접근하는 코드 영역
```java
  do {
    wait(mutex); // 입장 구역
    // 임계 구역
    signal(mutext); // 퇴장 구역
    // 나머지 구역
  }
```

