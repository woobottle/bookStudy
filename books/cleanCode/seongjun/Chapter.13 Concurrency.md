# Concurrency

* 동시성과 깔끔한 코드는 양립하기 어렵다.
* 스레드 하나면 쉽지, 근데 여러개는 어렵지...
* 테스트도 어렵고 ..



## Why Concurrency?

* 결합을 없애는 전략이다.
* 무엇과 언제를 분리하는 전략이다.
* 스레드 하나면 무엇과 언제가 밀접하다. 호출 스택을 보면 바로 드러남
* 무엇과 언제를 분리하면 어플리케이션 구조와 효율이 극적으로나아진다
* 거대한 루프가 아닌 작은 협력 프로그램 여럿으로 보임
* 따라서 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다.

### Servlet

* 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다.
* 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.
* 웹 컨테이너가 제공하는 decoupling 결합분리 전략은 완벽과 거리가 멀다.
* 서블릿은 동시성을 잘 구현하려면 각별한 주의와 노력을 기울여야한다.



* 구조적 개선만을 위해서 채택하는건 아님
* 응답 시간과 작업 처리량 개선을 위해 불가피함
* 단일 스레드 수집기는 웹 소켓에서 입출력을 기다리는 시간이 아주 많다.
* 한번에 한 사이트를 방문하는 대신 다중 스레드 알고리즘으로 수집기 성능을 높일 수 있음
* 사용자의 요청을 받아주는것도 마찬가지. 줄서야하자나

### Myths and Misconceptions 미신과 오해

* 반드시 필요한 상황이 있지만 어렵다.

### 미신 오해 

* 동시성은 항상 성능을 높여준다
  * 때로는 성능을 높여준다
    * 대기시간이 길어 스레드가 프로세서를 공유할 수 있거나 
    * 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아짐
* 동시성 구현해도 설계는 안변한다
  * 완전 다름. 크게달라짐
* 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야만 한다.

### 타당한 생각

* 부하를 유발한다 성능 측면에서 부하걸리고 코드 더짜야함
* 복잡하다, 간단한 문제라도 복잡함
* 버그는 재현이 어렵다, 일회성 문제로 여겨 무시하기 쉽다.
* 근본적인 설계 전략을 재고해야한다.

### Challenges

* ```java
  public class X {
  	private int lastIdUsed;
  	public int getNextId() { 
  		return ++lastIdUsed;
  	} 
  }
  ```

* 두 스레드가 한 인스턴스를 공유하면? 스케쥴링 순서대로 지 멋대로 숫자가 바뀌것지

## Concurrency Defense Principles

### SRP

* 동시성 관련 코드는 다른 코드와 분리해야한다? 
* 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
* 독자적인 난관이 있다. 다른 코드와 다르며 훨씬 어려움
* 잘못 구현한 동시성 코드는 별의별 방식으로 실패함,. ㅋ

##### 동시성 코드는 다른 코드와 분리해라!!!

### Corollary: Limit the Scope of Data - 따름 정리 : 자료범위를 제한하라

* synchronized 키워드로 보호하라고 ? 
* 이런 임계 영역의 수를 줄이는 기술이 중요하다.
* 공유 자료를 수정하는 위치가 많을수록 ...
  * 빼먹는다.
  * 잘 보호했는지 확인하느라 DRY하지 못함
  * 버그가 더어려움

##### 자료를 캡슐화 해라, 공유 자료를 최대한 줄여라

### Corollary: Use Copies of Data 

* 공유 자료를 줄이는거? - 애초에 공유 안하면 됨
* 어떤 경우에는 복사해서 읽기 전용으로만 사용
* 각 스레드가 복사해 사용 한 후 한 스레드가 사본에서 결과를 가져오는 경우도
* 물론 복사하는 시간과 부하가 걱정될지도.. 하지만 락 거는 시간 절약한게 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할듯

### Corollary: Threads Should Be as Independent as Possible

* 자신만의 세상에 존재하는 스레드를 구현한다.
* 자료를 공유하지 않는다.
* 비 공유 출처에서 갖고오고 로컬 변수에 저장하고...

##### 독자적인 스레드로 가능하면 다른 프로레서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라

### Know your Library

.. 자바 웅앵웅

* 스레드 환경에 안전한 컬렉션

##### 언어가 제공하는 클래스를 검토하라.



### Know your Execution Models

* Bound Resource - 다중 스레드 환경에서 사용하는 자원으로 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 쓰기/읽기 버퍼
* Mutual Exclusion - 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우
* Starvation - 오랫동안 혹은 영원히 자원을 기다린다. 항상 짧은 스레드에게 우선순위를 주면 긴 스레드는 기아상태
* Deadlock - 서로 끝나길 기다림
* LiveLock - 락을 거는 단계에서 각 스레드가 서로를 방해한다. . resonance로 인해 흑



## Producer - Consumer

* 하나 이상의 프로시저 스레드가 정보를 생성해 버퍼나 대기열에 넣음
* 하나 이상의 컨슈머가 가져와 사용함
* 대기열은 한정된 자원임
* 프로시저는 빈공간이 있어야 채움, 즉 빈공간을 기다림
* 컨슈머는 채워져야 가져옴 즉 채워질떄까지 기다림
* 스레드는 서로에게 시그널을 보냄
* 프로시저는 채운다음 대기열에 정보가 있다 라고 하고 기다리고
* 동시에 컨슈머는 빈공간이 있다 하고 보냄..;;ㄷ

## Readers Writers

* 읽기 스레드에서 공유자원을 쓴다고 침
* 쓰기 스레드에서 공유 자원을 갱신함
* 처리율이 문제다. throughput
* 처리율을 강조하면 starvation현상이나 오래된 정보가 쌓인다.
* 갱신을 허용하면 처리율에 영향을 미친다.
* 쓰기 스레드가 버퍼를 갱신하는 동안 읽기 스레드가 버퍼를 읽지 않으려면 ... 마찬가지로 반대로도??
* 균형잡기가 필요함.. 대개는 쓰기가 버퍼를 오래 점유해서 읽기가 기다리느라 처리율이 떨어짐
* 요구를 적절히 만족시켜 처리율을 적당히 높이고, 기아 방지도 필요함
* 일기가 없을 떄 까지 쓰기 스레드가 버퍼를 기다리는거 - 하지막 읽기 계속되면 기아
* 쓰기 우선권 주면 - 처리율이 떨어짐..

## Dining Philosophers

네 당신이 아는 그 데드락이요.

## Beware Dependencies Between Synchronized Methods

* 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

### 공유 객체 하나에는 메서드 하나만 사용해라...

* 여러개 써야하는 경우도 있긴한데 세가지 고려해보셈
  1. Client-Based Locking - 클라에서 첫 메서드를 호출하기 전에 서버에서 잠근다. 마지막 메서드 호출 까지 유지함
  2. Server-Based Locking - 서버에다 서버를 잠그고 모든 메서드 호출 후 잠금 해제하는 메서드 구현, 클라가 호출
  3. Adapted Server - 잠금을 수행하는 중간 단계를 생성한다. 서버에서 잠금 방식과 유사하지만 원래 서버 변경 X

### Keep Synchronized Sections Small

* 동기화하는 부분을 최대한 작게 만들어라
* 락은 스레드 지연시키고 부하 가중시킴 남발하면 노답..
* critical section - 임계영역 을 최대한 줄여야한다.

### Writing Correct Shut Down COde Is Hard

* 영구적으로 돌아가는 시스템을 구현하는 방법과 잠시 돌다 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다.
* 깔끔하게 종료하는 코드는 올바로 구현하기 어렵다. 
* 데드락! 
* 부모가 자식 다 끝나길 기다리면서 자원 해제 종료, 자식이 데드락? OMG
* 종료 시그널 받아서 부모가 자식에게 멈추라고 했음 근데 자식스레드 중 두개가 생산자/소비자라면?
* 생산자는 종료했는데 소비자가 메시지 기다린다면???

##### 종료는 개발 초기부터 고민하고 동작하게 초기부터 구현하라, 오래걸린다, 어렵다, 이미 나온 알고리즘 검토

## Testing Threaded Code

* 코드가 올바르다고 증명하기 불가능

* 그래도 충분히 위험을 낮춘다. 하지만 스레드가 늘어나면 복잡해진다.

  ##### 문제를 노출하는 테스트 케이스를 작성해라, 프로그램 설정과 시스템 설정, 부하를 바꿔가며 자주 돌려라.

##### 	실패하면 원인을 추적하고 다시 돌렸더니 성공한다는 이유로 그냥 넘어가면 안된다.

### 말이 안 되는 실패는 잠정적인 스레드 문제로 취급

* 말이 안되는 오류를 종종 일으킨다.

* 스레드가 다른 코드와 교류하는 방식을 직관적으로 이해 못한다.

* 실패를 재현하기 아주 어렵다.

* 우주선문제, 하드웨어 문제, 단순한 일회성 문제로 치부한다.

* 계속 문제를 무시하다 보면 잘못된 코드 위에 코드가 계속 쌓인다.

  ##### 시스템 실패를 일회성이라 치부하지 마라

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

* 스레드 환경 밖에서 제대로 도는지 먼저 확인한다 ..

  ##### 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라, 먼저 밖에서 돌려

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워넣을 수 있도록 스레드 코드를 구현

* 다양한 설정으로 실행이 쉽게 만든다

* 한 스레드, 여러 스레드로 실행해보거나 실행 중 스레드 수를 바꿔본다.

* 실제환경 / 테스트환경에서 돌려본다.

* 빨리, 천천히. 다양한 속도로 돌려본다.

* 반복 테스트가 가능하도록 테스트케이스를 작성한다.

  ##### 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라

### 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성해라

* 적절한 스레드 개수를 파악하려면 상당한 시행착오
* 처음부터 다양한 설정으로 성능 측정하는 방법을 강구한다.
* 스레드 수를 조율하기 쉽게 코드를 짠다.
* 런타임에서 스레드 개수를 변경하는 방법도 고려한다.
* 프로그램 처리율과 효율에 따라 스레드 개수를 조율하는 코드도 고민한다.

### 프로세스 수보다 많은 스레드를 돌려본다

* 시스템이 스레드를 스와핑 할 때도 문제가 발생한다.
* 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌린다.
* 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드 찾기가 쉬움

### 다른 플랫폼에서 돌려본다

* 운영체제마다 스레드를 처리하는 정책이 달라 결과가 달라진다.

* 프로그램 돌아가는 곳에서 돌려야함

  ##### 모든 목표 플랫폼에서 코드를 돌려라

### 보조코드를 넣어 돌린다. 강제로 실패를 만든다.

* 오류 찾기 힘드니, 소수만 실패하니, 실패하는 경로가 실행되기 힘드니..

* 그냥 wait / sleep / 이런거로 코드를 다양한 순서로 실행한다.

* 잘못된 코드면 가능한 초반에 , 가능한 자주 실패하는편이좋다.

* ##### 직접 구현하기

  * 그냥 뭐 직접 wait() , sleep(), yield(), priority() 를 넣는다.
  * 저거 추가해서 실패한게 아닌 그냥 증거가 드러난것

* ##### 직접 구현 문제점

  * 직접 위치 찾아야함
  * 어디서 호출해야 적당한지 어케알지
  * 배포할때 그대로 남겨두면 성능 ㄷ
  * 무작위적임 ..안드러날 확률 높다.

* 테스트환경에서 보조 코드를 실행할 방법이 필요하다. 실행마다 설정을 바꿔줄 방법도 필요하다,

* ##### 자동화

  * AOF, CGLIB, ASM 등

  * ```java
    public class ThreadJigglePoint {
    	public static void jiggle() { }
    }
    public synchronized String nextUrlOrNull() { 
      if(hasNext()) {
    		ThreadJiglePoint.jiggle(); 
        String url = urlGenerator.next(); 
        ThreadJiglePoint.jiggle();
        updateHasNext(); 
        ThreadJiglePoint.jiggle(); 
        return url;
    }
    return null; }
    ```

  * jiggle()은 무작위로 sleep이나 yield를 호출 때론 아무것도 안함

  * 하나는 비워두고 배포환경에서 쓴다.

  * 하나는 무작위로 nop sleep yield를 쓴다.

  * 테스트 수천번 실행하면 에러 난다. ㅎㅎ

  * IBM ConTest도 있음

  * ##### 흔들기 기법을 사용해서 오류를 찾아라

### 결론

* 스레드는 올바로 구현하기 어렵다. 싱글스레드와는 차원이 다름
* SRP를 준수한다..... POJO를 사용해 스레드를 아는 코드, 모르는 코드 분리
* 스레드만 테스트
* 라이브러리 기본 알고리즘 이해하고
* 임계영역 잘 설정하고
* 공유상태 관리 클라에게 책임을 넘기지말고
* 테스트 잘 하고 
* 시간들여서 보조코드 추가하고, 자동화 기술 쓰고..





