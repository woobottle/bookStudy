# 리팩터링 2판

## Chapter 2. 리팩터링 원칙

### 리팩터링이란?

소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법(명사적 의미)

"리팩터링을 한다"는 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다는 의미를 갖는다.

리팩터링 기법 - 함수 추출하기, 조건부 로직을 polymorphic으로 변형하기 등이 이에 해당

리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

+ 왜하는가?

  + 이해하고 수정하기 쉬운코드를 만들기 위해

+ 무엇을?

  + 내부 구조를 변경

+ 어떻게?(focus)

  + 겉보기 동작은 그대로 유지한 채 

+ 리팩터링은 그 과정에서의 겉보기 동작 유지가 중요한 것!

  + 리팩터링의 특징은 무엇을 하느냐가 아니라 어떻게 하느냐에 초점을 두는 것

  

### Restructuring vs Refactoring

+ restructuring은 코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 일컫는다
+ refactoring은 모든 리스트럭쳐링 중에서 도중에 중단되더라도 동작이 그대로 유지되는 것을 일컫는다, 리스트럭쳐링의 특수한 한 형태

리팩터링과정에서 발견한 버그는 리팩터링 후에도 그대로 남아있어야한다(아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다)

리팩터링은 성능에 초점을 두는 게아니라 이해하기 쉽고 수정하기 쉬운 코드를 만드는데 초점을 둔다. 리팩토링을 거침으로 인해 성능이 낮아질 수도 있고, 높아질 수도 있다.



### 두개의 모자(기능 추가, 리팩터링)

모자로 표현한 이유는 머리는 하나인데, 두 개의 모자를 동시에 쓸 수 없기때문으로 추측, 즉 기능 추가와 리팩터링은 동시에 이루어지는 것이 아니다.

기능추가 모자를 썼을 때는 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 해야한다. 이것에 대한 진척도는 테스트를 추가하여 통과하는지 확인하는 방식으로 측정한다.

리팩터링 모자를 썼을 때는, 부득이한 경우가 아니라면, '테스트'마저 수정하지 않는다. 오로지 코드 재구성에만 전념한다.

단, 리팩터링과 기능 추가는 밀접하게 얽힌 경우가 많기 때문에  리팩터링 커밋과 기능추가 커밋을 분리하는 것은 시간낭비가 될 수 있다.

이에 대한 대안책으로는 최종 커밋은 하나로 묶되, 코드 리뷰는 여러 revision으로 나누어 검토한다.

git의 stash/commit/rebase 등의 기능을 잘 활용하면 예술적으로 적용할 수 있다.



내가 현재 어떤 모자를 쓰고있는지, 그에 따른 미묘한 작업 장식의 차이를 분명하게 인식해야한다.



### 리팩터링, 왜 하는가?

+ 소프트웨어의 설계가 좋아진다

  + 코드만 봐서는 설계를 파악하기 어렵다.
  + 코드 구조가 무너지기 시작하면 악효가가 누적된다
  + 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워진다.
  + 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.
  + 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다.
    + 추후 수정 시 들어가는 노력이 크게 달라진다
    + 코드가 길수록 실수없이 수정하기 어려워진다.
    + 이해 해야 할 코드량도 늘어난다.
    + 비슷한 일을 하는 코드가 산재해 있다면 한 부분만 살짝 바꿔서는 시스템이 예상대로 작동하지 않을 수 있다.
    + 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있고, 바람직한 설계의 핵심이다.

+ 소프트웨어를 이해하기 쉬워진다

  + 나중에 누군가 내가 작성한 코드를 볼 때 이해가 쉬워진다.
  + 이 코드의 동작이 어려워 나중에 누군가에게 설명하기 위해 기억을 하고있다면, 이는 잘못된 코드임을 의심해봐야한다.

+ 버그를 쉽게 찾을 수 있다.

  + 코드를 이해하기 쉽기 때문에 버그도 어디서 발생하는지 금새알 수 있다.

+ 이런 이유들로 프로그래밍 속도 즉, 생산성을 올릴 수 있다.(경제 문제와 직결)

  + 이해하기 쉽다
  + 수정할 부분이 줄어든다
  + 버그가 줄어든다
  + 기존의 설계가 잘 되어있다면 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있고, 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다. 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.(설계 지구력 가설)

+ 설계 지구력 가설

  + 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.
  + 설령 요구사항이 변경될지라도 기존의 설계를 지속하며 개선할 수 있다.
  + 처음부터 좋은 설계를 마련하기란 매우 어렵다.

  

### 리팩터링, 언제 하는가?

1. 3의 법칙 - 삼진아웃 리팩터링
   1. 일단 개발한다
   2. 같은일을 두 번하게되면... 일단 한다
   3. 또 같은일을 하게되면, 리팩터링이 필요한 것이다
2. 준비를 위한 리팩터링 - 기능을 쉽게 추가하게 만들기
   1. 기능을 추가하기 직전에, '리펙터링하면 더 쉽게 추가 할 수 있지 않을까'고민
   2. 기능을 추가하기 직전이 리팩토링할 적기이다.
   3. 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 부분을 찾는다.
3. 이해를 위한 리팩터링 - 코드를 이해하기 쉽게 만들기
   1. 코드를 파악해야 할 일이 있을 때, 이해한 내용을 더 잘 반영할 수 있도록 리팩터링
   2. 리팩터링을 하다보면 기능이해를 하기 위해 기존의 코드를 봐야하는데 이것을 정리하다가보면 프로그램의 청사진이 눈에 들어오게 된다.
4. 쓰레기 줍기 리팩터링
   1. 코드를 파악하다가 '비효율적으로 처리하는 모습을 발견'하면 리팩터링
   2. 여기서 말하는 비효율은 로직이 쓸데없이 복잡하거나 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해 놨을 수 있음을 의미
   3. 차근차근 보이는 것마다 해나가면 언젠가는 다 할 수 있다.
5. 수시로 하는 리팩터링
   1. 따로 리팩터링하는 시간을 가지는게 아니라 개발 과정에서 같이
   2. 기능을 추가하거나 디버깅할 때 리팩터링도 같이한다.
   3. 보기 싫은 코드를 발견하면 리팩터링하자.
   4. 이미 잘 작성된 코드라고 해도 리팩토링을 거쳐야 할 수 있다.
   5. 기능을 추가를 빠르게 하는 방법은 새 기능을 추가하기 쉽도록 기존 코드를 수정하는 것이다.
   6. 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다.
   7. 리팩터링은 계획적으로 하는 것이 아닌 드러나지 않게 기회가 될때마다 하는 것이 맞다 
6. 코드 리뷰에서 리팩터링
   1. 코드 리뷰를 할 때, 실제로 리팩터링 해보기
   2. 리팩터링을 하면 떠올릴 수 없던 아이디어도 떠오르게된다.
   3. 성취감을 맛볼 수 있다.
   4. 코드리뷰를 할 때는 풀리퀘가 아닌 페어프로그래밍 형태가 좋다.
7. 리팩터링을 하지 말아야 할 때
   1. 지저분해도 굳이 수정할 필요가 없다면 하지 말기
      1. 외부 API를 다루둣 호출해서 쓰는 코드라면 지저분해도 그냥 두고 내부 동작을 이해해야할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
   2. 차라리 새로 작성하는게 쉬울 때 하지 말기



### 리팩터링 시 고려할 문제

특정한 기술, 도구, 아키텍처 등을 내세울 때마다 문제점을 찾고 이것을 언제 어디에 적용할지 판단하려면 손익을 제대로해야한다.

리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다. 코드를 예쁘게 만들기 위해 하는 것이 아니다.

내가 직접 건드릴 일이 없거나, 불편한 정도가 그리 심하지 않다면 리팩터링을 하지 않는다.

 

### YAGNI(You Aren't Going to Need it)

1. 코딩을 시작하기 전에 아키텍쳐를 확장해야한다.

=> 요구사항 사전 파악이 현실적으로는 불가능하다.

2. 유연성 매커니즘 심기

=> 아 이거는 미래에 이렇게 될 거 같다를 예상하고 미리 만들어 놓는 것

=> 되려 대응능력 저해, 필요없는데 만들어 놓았으니 나중에 이해하기 어려울 수 있다.

3. YAGNI						
   1. 추측하지 말고 현재 요구사항만 충족해라
   2. 대신 그것을 최대한 멋지게 해결하도록 설계해라
   3. 나중에 더 잘 이해하게 되면 리팩터링을 통해 바꾼다
4. 선제적 아키텍쳐에 소홀하라는 뜻이 아니라 이미 알고 있는 부분은 최대한 미리 준비하는 게 좋지만, 모르는 것을 미리 대비하기 보다는, 이해하고 나서 반영하는게 효율적



### 리팩터링과 성능

직관적 설계 vs 성능

리팩터링은 이해하기 쉬운 코드를 위해 '속도가 느려지는'방향인 경우가 많다

성능이 느려져도 상관없으니 보기좋은 코드가 좋다(X)

하드웨어가 발전해서 그 정도 성능저하는 아무 문제 없을 것(X)

성능을 튜닝하기는 쉬워지기 때문에 오히려 성능이 좋아진다(O)

90퍼센트의 시간은 낭비(리팩터링을 하지 않는다는 가정 하에 100개의 함수가 있다고 했을 때 함수 각 자체의 성능이 10%씩 빠를 수는 있다. 왜냐하면 리팩터링은 이해하기 쉬운 코드를 만들기 위해 속도가 느려지는 방향인 경우가 많으므로, but, 실제로 시간을 많이 잡아먹는 것은 100개 중에 10개 정도이고 100개 전체를 10%빨리만드는 것보다 이 10개를 50%빠르게 수정하는 것이 성능이 좋아진다.)

1) 성능에 신경쓰지 않고, 보기좋게 코딩한다.
2) 성능 최적화 단계가 되면, 프로파일러로 분석하여 오랜 시간을 잡아먹는 코드를 특정한다
3) 그 부분을 개선

리팩터링이 잘 된 코드는 성능 분석에 유리하다.

리팩터링을 개발속도가 빨라지기 때문에 성능 튜닝에 더 많은 시간을 투자할 수 있다는 장점도 있다.