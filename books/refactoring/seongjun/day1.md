# 리팩터링 원칙

## 1. 리팩터링의 정의

**리팩터링**: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

* **함수 추출**하기와 **조건부 로직을 다형성으로 바꾸기** 처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당

**리팩터링(하다)**: 소프트웨어의 겉보기 동작은 그대로 유지한 채 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

* 결국 리팩터링하는 동안에는 코드가 항상 정상 작동해야 한다는 것
* 코드를 정리하거나 구조를 바꾸는 모든 작업을 재구성( restructuring )을 한다 로 하고
* 그 중 특수한 한 형태로 리팩터링을 정의
* 겉보기 동작이 같다 -> 완전히 같아 한다는 뜻은 아니고, 성능적으로 달라질 수도 있지 ( 콜스텍이 달라져서 )
* 하지만 사용자 관점에서 코드가 똑같이 동작해야한다
* 마치 성능 최적화처럼 기능은 유지한다. 다만 목적이 다를 뿐

## 2. 두 개의 모자

* 기능 추가냐 리팩터링이냐를 명확히 구분해 작업한다.
* 기능 추가 모자를 쓴 다음 - 기존 코드는 절대 건드리지 않고 새 기능을 추가
* 리팩터링 모자를 쓴 다음 - 기능 추가는 절대로 하지 않고 오로지 코드 재구성에만 전념 ( 테스트 조차 새로 안 만든다 )

## 3. 리팩터링하는 이유

* 만병통치약은 절대 아니지만 코드를 건강한 상태로 유지하는 데 도와주는 약은 분명
* 다양한 용도로 활용할 수 있고 반드시 그래야 하는 도구

### 리팩터링하면 소프트웨어 설계가 좋아진다.

* 리팩터링하지 않으면 내부 설계가 썩기 쉽다. 
  * 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
  * 코드를 보고 설계를 파악하기 어려워진다.
  * 설계가 부패되고 계속 가속됨
* 같은 일을 하더라도 설계가 나쁘면 코드가 길어지고 중복이 늘어난다.
  * 중복 제거는 설계 개선 작업의 중요한 한 축이다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

* 잘 읽혀야 하지 아시죠?
* 코드의 목적이 더 잘 드러나게, 내 의도를 더 명확하게 전달하도록 개선하자

### 리팩터링하면 버그를 쉽게 찾을 수 있다.

* 프로그램의 구조를 명확하게 다듬으면 '이럴 것이다'라고 가정하던 점들이 분명히 드러난다

### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

* 기능이 누적될 수록 코드를 짜는 시간이 오래걸린다
* 좋은 설계는 새로운 기능을 추가할 지점과 어떻게 고칠지 쉽게 찾을 수 있다.
* 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.

## 4. 언제 리팩터링해야 할까?

* 거의 한시간 간격으로 한다?
* 3의 법칙
  1. 처음에는 그냥 한다
  2. 비슷한 일을 두 번째로 하게 되면 일단 계속 진행한다.
  3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

* 리팩터링하기 가장 좋은 시점은 기능을 새로 추가하기 직전
* 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.
* 예를들어 리터럴 값 몇 개가 방해되는 함수
  * 함수 복제해서 해당 값만 수정해도 됨 - 하지만 중복
  * 리팩터링 모자를 쓰고 **함수 매개변수화하기** 를 적용한다
* 준비를 위한 리팩터링으로 상황을 개선해놓으면 
  * 버그가 수정된 상태가 오래 지속될 가능성을 높이고 
  * 같은 곳에서 다른 버그가 발생할 가능성을 줄인다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

* 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
* 조건부 로직의 구조가 이상하지 않은지 살펴보고
* 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지
* 기억력에 의존한 세부사항을 숨겨놓진 않았는지

### 쓰레기 줍기 리팩터링

* 코드 파악중 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 여러 함수로 쓰거나 하는 것을 발견
* 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 뻇기긴 싫다.
* 간단하면 즉시 수정
* 쫌 걸리면 메모 남기고 하던일 끝내고 처리한다.

### 계획된 리팩터링과 수시로 하는 리팩터링

* 보기 싫은 코드를 발경하면 리팩터링한다.
* 잘 작성된 코드 역시 수많은 리팩터링을 고쳐야한다.
* 새 기능을 추가하기 쉽도록 코드를 수정하는 것이 그 기능을 가장 빠르게 추가하는 것
* 계획된 리팩터링이 나쁘다는 말은 아니다.
  * 그간 리팩터링에 소홀했다면 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선해야함
* 그래도, 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해라
* 굳이 커밋 나눌 필요도 없고, 기능 추가와 밀접하게 연관되어있으므로 ... 리팩터링한 맥락을...

### 오래 걸리는 리팩터링

* 라이브러리를 새 것으로 교체하거나
* 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼야하거나
* 작업 하면서 쌓여온 골치 아픈 의존성을 정리하는 작업
* 팀 전체가 달려들어서 몇주 내내 매달리는건 회의적
* 조금씩 해결해가는 편이 효과적이다.
* 일부를 변경해도 모든 기능이 항상 올바르게 동작 하는게 리팩터링의 장점

### 코드 리뷰에 리팩터링 활용하기

* pr방식에는 효과적이지 않다.
* 페어 프로그래밍 하면서 같이 리팩터링

### 관리자에게는 뭐라고 말해야 할까?

* 리팩터링이 아닌 어설픈 restructring작업을 하면서 오히려 코드베이스를 망가뜨리면 불신 증폭
* 금기어처럼,, 리팩터링한다고 말을 하지말라, 기능 구현을 빨리하는 길은 리팩터링, 리팩터링부터한다.

### 리팩터링하지 말아야 할때

* 외부 api다루듯 호출해서 쓰는 코드라면? 
  * 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
* 처음부터 새로 작성하는 게 쉬울 때도

## 5. 리팩터링 시 고려할 문제

* 리팩터링에 딸려 오는 문제가 있다.

### 새 기능 개발 속도 저하

* 리팩터링의 궁극적인 목적은 개발 속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
* 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이면 주저하지 않고 리팩터링부터 한다.
* 건드릴 일이 거의 없거나, 그리 심하지 않으면 안함
* 어떻게 해야할 지 모르겠으면 미루거나 일단 해보고 살펴본다.
* 리팩터링은 도덕적인 이유로 하는 것이 아닌 경제적인 이유로 하는 것

### 코드 소유권

* API로 제공된 것이라면?
* 예를들어 함수 이름을 변경할 때 기존 함수는 유지하면서 함수 본문에서 새 함수를 호출하도록..
* 기존 인터페이스를 폐기 대상으로 두고 시간이 흐른 뒤 삭제
* 필자는 코드의 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대함
  * 팀에 소유권을 주는 것

### 브랜치

* 기능 단위로 브랜치를 따서 작업
  * 독립 브랜치 작업 기간이 길어질수록 마스터로 통합하기 어려워진다.
    * 해결하고자 마스터를 수시로 리베이스하거나 머지함
    * 머지는 브랜치만 바뀌고 마스터는 그대로
    * 통합은 마스터로 올리는 것
* 만약 함수를 호출하는데 다른 브랜치에서 그걸 이름을 변경했다면? ㅜㅜ유유
* 지속 통합 !
  * 모든 팀원들이 최소 하루에 한번은 마스터와 통합하게
  * 이렇게 하면 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 낮출 수 있다.
  * 대신 마스터를 건강하게 유지하고
  * 거대한 기능을 잘게 쪼개는 법을 배우고
  * 각 기능을 끄고 킬 수 있는 feature flag / toggle을 적용해야한다.
* CI는 리팩토링과 궁합이 좋다. 충돌을 빠르게 해결
* CI와 리팩터링을 합쳐서 익스트림 프로그래밍 - XP

### 테스팅

* 리팩터링은 프로그램의 겉보기 동작이 동일하다.
* 이에대한 검증을 위한 테스트 스위트가 필요하다. 그리고 수시로 테스트해야함
* 즉 리팩터링을 하려면 self testing code를 마련해야한다
* CI에 통합된 테스트는 XP의 권장 사항이자 CD의 핵심이다.
* https://jay.bazuzi.com/Safely-extract-a-method-in-any-C++-code/

### 레거시 코드

* 레거시를 파악할 때 리팩토링은 도움된다.
* 테스트 코드 없이 명료하게 리팩터링하기 어려움
* 테스트 보강이 필요함
* 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트가 가능함
* 이래서 ..처음부터 자가 테스트 코드가 있어야한다 ㅜㅜ
* 어쨋든 테스트 없이 리팩터링 하고 테스트를 짜고... 위험하지만 해야함

### 데이터베이스

* 진화형 데이터베이스 설계와 데이터베이스 리팩터링 기법
  * 커타란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트 작성
  * 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합
* 컬럼명을 변경한다고 생각해보자
  * 함수 선언 바꾸기에 따르면 이걸 쓰는 코드를 다 찾아서 한 번에 변경
  * 마이그레이션 스크립트를 함께 실행
* 단계별로 나눠서 릴리스 하는 것이 대체로 좋다
  * 새 필드 추가 - 빈 값
  * 기존 필드와 새 필드를 동시에 업데이트 하도록 설정
  * 새 필드로  교체
  * 예전필드를 삭제
* 병렬수정의 예임

## 6. 리팩터링, 아키텍처, 애그니 YAGNI

* 수년 동안 운영되던 소프트웨어여도 아키텍처를 대폭 변경할 수 있다..
  * 하지만 역시 어려워~
* 아키텍처를 미리 다 확정 짓고서 짜는건 요구사항이 사전에 모두 파악되어야하고
  * 실제로는 실현할 수 없는 목표
* 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어둔다.
  * 물론 당장 쓰임에 비해 너무 복잡해짐
  * 잘못 구현할 떄도있다.
* 유연성 메커니즘은 리팩터링을 활용하면 다르게 접근이 가능하다.
  * 추측하지 않고 현재 요구사항까지만
  * 요구사항을 더 잘 이해하면 리팩터링해서 바꾼다.
  * 항상 같은 값을 넘기는 매개변수는 목록에 넣지 않고 추가해야 할 때 **함수 매개변수화하기**로 해결한다
* 이런식의 설계를 간결한 설계, 점진적 설계, YAGNI에니그등으로 부른다.
  * You Aren't Goging to Need It 
* YAGNI를 받아들인다고 해서 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아니다.
* 다만 둘 사이의 균형이 달라졌다는 것 - 나중에 더 깊이 이해하게 되었을 때 처리한다.

## 7. 리팩터링과 소프트웨어 개발 프로세스

* TDD
* 최초의 애자일 소프트웨어 방법론중 하나로 등장한 XP
* 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들어야한다.
* 테스트 코드를 통해서 리팩터링을 안전하게
* 지속적 통합을 통해 다른 사람의 작업을 방해하지 않으면서 언제든 리팩터링 할 수 있도록
* 그리고 리팩터링
* 이게 기반이 되어야 YAGNI가 가능

## 8. 리팩터링과 성능

* 직관적인 설계 vs 성능
* 느려질 수도 있다, 하지만 튜닝하기에는 더 쉬워짐
* 하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은 먼저 튜닝하기 쉽게 만드는 것
* 빠른 소프트웨어를 작성하는 세 가지 방법은
  1. 시간 예산 분배 방식
     * 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원 예산을 할당
     * 주어진 자원을 서로 주고받는 메커니즘을 제공할 수는 있음
     * 엄격한 시간 엄수
  2. 끊임없이 관심을 기울인다.
     * 개발자는 직관적으로 높은 성능을 유지하기위해.. 여러 수정을 하지만 실제 효과는 변변치 않다.
     * 각각의 개선이 특정 프로그램의 동작에만 관련될 뿐 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때도 많다..
     * 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다. 전체를 고르게 최적화 하면 90프로는 효과가 거의 없는 시간 낭비
  3. 일단 신경 안쓰고 작성하고 최적화 단계가 되었을 때 절차에 따라 튜닝
     1. 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다
     2. 그 부분들을 개선한다.
     3. 각 단계마다 컴파일,테스트, 프로파일러 

## 9.리팩터링의 유래

* 스몰토크를 활용해 개발하다가 XP가 탄생
  * 스몰토크는 기능이 풍부한 소프트웨어를 빠르게 작성할 수 있는 역동적인 환경, 
  * 컴파일-링크-실행 주기가 짧아서 수정 작업을 빠르게 가능
* 어쩌구~

## 10.리팩터링 자동화

* 함수명 변경
* 변수 추출하기
* 함수 추출하기
* 강타입이 역시 좋긴해

## 11. 더 알고 싶다면

* 리팩터링 워크북 - 조슈아케리에프스키-인사이트
* 리팩토링 데이터베이스 - 스캇 엠블러, 프라모드 사달게-위키북스
* 리팩토링 HTML - 엘리엇 러스티 해롤드 - 에이콘 출판사
* 래거시 코드 활용 전략 







































