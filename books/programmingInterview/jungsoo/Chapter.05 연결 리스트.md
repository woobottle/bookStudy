## 왜 연결 리스트인가?

- 보통 표준 라이브러리를 사용하면 되지만 면접 때는 완전히 이해하였다는 보여주기 위해 직접 구현하는 걸 보여줘야 할 가능성이 높다.

## 연결 리스트의 종류

### 단일 연결 리스트

![단일 연결 리스트](https://user-images.githubusercontent.com/72548112/139040307-f4d02c1e-81fe-4816-a4cc-cadd2aa58446.png)

- 각 원소에는 다음 원소에 대한 연결고리(link)가 들어있다.  
  첫 번째 원소는 head, 마지막 원소는 tail이라 부르며 연결고리는 비어 있거나 널로 이어져 있다.

- 앞으로만 종주할 수 있으며 리스트에 있는 모든 원소의 위치를 파악하기 위해선 첫 번째 원소에 대한 포인터나 레퍼런스가 있어야만 한다.

- 포인터나 레퍼런스는 보통 별도의 자료구조에 저장한다.

---

### 이중 연결 리스트

![이중 연결 리스트](https://user-images.githubusercontent.com/72548112/139040594-d29c74c8-0f95-4578-b03f-716b4e6237c2.png)

- 각 원소마다 다음에 오는 원소에 대한 연결고리 외에 앞에 있는 원소에 대한 연결고리도 들어있다.

- 어느 방향으로든 종주할 수 있기에 어떤 원소에서 시작하든 리스트 전체를 종주하는 것이 가능하다.

- 단일과 마찬가지로 head와 tail이 있다.

- 오히려 단일을 쓰는것 보다 이중을 사용하는게 더 복잡해질 수 있기에 쓰지 않게 되는 경우도 있다.

---

### 원형 연결 리스트

- 단일 연결 리스트로 된ㄴ 것도, 이중 연결 리스트로 된 것도 있다.

- head와 tail이 없다.

- 다음 원소를 가리키는 포인터나 레퍼런스에 반드시 널이 아닌 원소가 들어간다.

---

---

## 기초적인 연결 리스트 연산

- 머리 원소 추적, 리스트 종주, 리스트 원소 추가 및 제거 등이 있다.

- 이중 연결 리스트를 쓰면 너무 쉽기 때문에 단일 연결 리스트에 초점을 맞췄다.

### 머리 원소 추적

- 단일 연결 리스트에서는 머리 원소를 추적하지 않으면 가비지 컬렉터에 의해 제거되거나 어딘가에서 길을 잃고 만다.

- 따라서 첫 번째 원소가 변경되면 head에 대한 포인터 or 레퍼런스를 갱신해야 한다.

### 리스트 종주

- 머리 원소가 아닌 다른 원소를 가지고 작업해야 하는 경우, 원소 중 일부를 종주해야 할 수도 있으며 리스트가 끝나지 않는지 확인을 해야 한다.

- 리스트 끝을 지나갔는데도 원하는 원소를 못 찾았으면 예외를 던지는 코드가 더 나을 수도 있다.

### 원소의 삽입 및 삭제

- 다음 원소에 대한 연결고리를 통해서만 관리할 수 있기 때문에 중간에서 삽입, 삭제하려면 앞 원소의 연결고리를 수정해야 한다.

- 삭제할 원소 또는 삽입할 원소만 지정된 상황이라면 바로 앞 원소를 찾아낼 방법이 없기 때문에 head에서 종주해야만 할 수도 있다.

- 삭제할 원소가 head라면 더 주의를 기울여야 한다.

- C나 C++ 처럼 가비지 컬렉션이 없는 언어에서 삭제할 때는 모든 원소를 지울때 head부터 하나씩 제거하면 문제가 발생한다.  
  => 포인터로 넘어가는 작업과 원소를 제거하는 작업 중 어느 것을 먼저 해야하는지.  
  => 2개의 포인터를 사용하자.

---

---

## 연결 리스트 문제

### 스택 구현법

> 스택 자료구조에 대해 논하라. 연결 리스트, 또는 동적 배열을 사용하여C로 스택을 구현하고 그 자료구조를 사용한 이유를 설명하라. 완전하고 일관성 있으면서 사용하기 편리한 스택 인터페이스를 설계하라.

- 문제 출제 의도

  1. 기본적인 자료구조에 대한 지식
  2. 자료구조를 조작하기 위한 루틴을 만드는 능력
  3. 일련의 루틴에 대한 일관성 있는 인터페이스를 설계하는 능력

- 스택

  - 후입선출(LIFO)
  - 삽입(push), 삭제(pop)
  - 하위 작업으로 나눌 수 있는 작업을 관리할 때 유용.
  - 서브루틴에서 사용할 반환 주소, 매개변수, 지역 변수 등을 추적, 프로그래밍 언어릉 파실할 때 토큰 추적.

- 배열이 추가될 때마다 필요에 따라 크기가 변하는 동적 배열을 사용하여 구현 가능하다.

  - 장점 : 연결 리스트에 비하면 배열 원소에 대한 임의 접근이 가능
  - 단정 : 스택에 대한 연산은 끝에서만 이뤄지기 때문에 장점이 별 힘을 발휘할 수 없다. 크기를 조절하는 과정에서 기존 모든 원소들을 새 배열로 복사해야하기 때문에 시간이 오래 걸릴 수 있다.

- 연결 리스트에서는 각 원소마다 메모리를 동적으로 할당해야 한다.

  - 단점 : 메모리 할당자의 오버헤드에 따라 동적 배열보다 메모리 할당에 더 오랜 시간이 걸릴 수도 있다. 인점한 원소는 메모리상에서 떨어져 있을 수도 있다.

- 동적 배열은 메모리 국소성 면에서 장점이 있는데 프로세서가 메모리보다 훨씬 빨라짐에 따라 그 중요성은 점점 더 커지고 있다.

- 이런 이유로 동적 배열을 기반으로 하는 스택이 연결 리스트를 기반으로 하는 스택에 비해 대체로 빠른 편이다.

- 연결 리스트는 구현하는 것이 훨씬 덜 복잡하기 때문에 면접에서는 연결 리스트를 써서 푸는 쪽이 훨씬 낫다.

- 각 접근법의 장단점을 상세하게 설명할 수 있어야 한다.

---

- 무엇을 쓰기로 결정했는지를 설명하고 나면 루틴과 인터페이스를 설계해야 한다.

- 전체적인 계획이 중용한 큰 프로젝트에서도 무작정 코딩을 시작하는 실수를 범하지 않으리라는 믿음을 심어줄 수 있다.

- 설계하는 방법, 기능, 오류 처리에 대한 흐름~

- pop 인터페이스는 두 가지로 만들 수 있을 것이다.
  - 오류 코드 변수에 대한 포인터를 인자로 받아들이고 데이터를 반환.
  - 반대로 데이터 변수에 대한 포인터를 인자로 받아오고 오류 코드를 반환.

---

- 면접시에는 장단점을 제대로 설명하고 내가 제시한 풀이법을 적절하게 합리화할 수 있다면 어느 쪽이든 별문제가 되진 않을 것이다.

- `createStack` / `deleteStack` 함수도 만들면 프로그램 자체는 걸드리지 않으면서도 스택을 구현하는 방법을 전부 뜯어고치는 것도 가능하다.

- 일관성을 위해 이 함수에서도 오류 코드를 반환하는 것이 좋다.

- 객체지향 언어를 사용한다면 인터페이스를 훨씬 더 깔끔하게 설계할 수 있다.

---

## 연결 리스트의 꼬리 포인터

> 정수를 저장하기 위한 어떤 단일 연결 리스트의 첫 번째와 마지막 원소를 가리키는 head와 tail이라는 전역 포인터가 있다. 다음과 같은 함수 원형에 대한 C 함수를 구현하라.
>
> ```
> bool delete( Element *elem);
> bool insertAfter( Element *elem, int data);
> ```
>
> delete 함수의 인자는 삭제할 원소다. insertAfter 함수의 두 인자는 각각 새로 추가되는 원소의 바로 앞 원소에 대한 포인터와 새 원소의 데이터다. insertAfter 함수를 호출할 때 NULL을 넘겨주는 방식으로 리스트 맨 앞에도 새 원소를 추가할 수 있어야 한다. 함수가 성공적으로 실행되면 true, 그렇지 않으면 false를 반환한다.  
> head와 tail 포인터는 항상 최긴 값으로 유지해아 한다.

- 이 문제에서 특이한 부분은 꼬리 포인터를 관리해야 한다는 요구사항 뿐.  
  딱히 새로운 알고리즘을 설계할 필요보다 상황에 따라 head와 tail 포인터만 고쳐주면 될듯.

- 특별한 케이스를 여러 개 처리하다 보면 그중 일부를 놓치는 일을 빈번하게 경험. 특히 특별 케이스 내부에 또 다른 븍별 케이스가 섞여 있는 경우.

- 알고리즘을 구현할 때는 리스트 길이가 0, 1, 2일 때도 모두 정확하게 작동하는지 확인해야 한다.

- 반복문을 만들 때 어떤 원소도 빼먹지 않도록 해야 한다.

- 면접관에게 제출하기 전에 마지막으로 한번 더 체크

- 알고리즘을 설계할 때 특별 케이스 개수를 꼼꼼하게 세는 습관을 길러두면 좋다.

- 특별 케이스를 설계할 때 찾아내는 프로그래머가 디버깅할 때 찾아내는 프로그래머보다 생산성이 더 높을 것이다.

- 특별 케이스만을 위한 코드보다 더 일반화해서 특별 케이스까지도 일반 케이스로 처리할 수 있으면 더 간결하고 우아한 코드가 된다.

---

## removeHead의 버그

> 단일 연결 리스트에서 맨 앞에 있는 원소를 제거하기 위한 용도로 만들어진 다음 C 함수에 있는 버그를 찾아내서 수정하라.
>
> ```
> void removeHead( ListElement *head ){
>   free( head );
>   head = head -> next;
> }
> ```

- 보통 주어지는 코드의 분량이 적기 때문에 실제 프로그래밍을 할 때 버그를 잡아내는 방법하고는 조금 다른 전략을 적용해야 한다.

- 디버거를 쓰지 않고 함수에 있는 각 줄을 체계적으로 분석.
  1. 데이터가 함수에 제대로 들어오는지 확인
  2. 함수의 각 줄이 제대로 작동하는지 확인
  3. 함수에서 데이터가 올바르게 나오는지 확인
  4. 흔히 발생하는 오류 조건을 확인

---

## 연결 리스트의 마지막에서 m번째 원소

> 단일 연결 리스트가 주어졌을 때 리스트의 맨 뒤에서 m번째 원소를 찾아내는 알고리즘을 만들어 보라. 이때 시간 및 공간 효율을 모두 고려해야 한다. 오류 조건의 처리에 주의하여 알고리즘을 구현하라. 여기에서 '맨 뒤에서 m번째 원소'는 m = 0일 때 리스트의 마지막 원소를 반환하는 식으로 생각한다.

- 단일 연결 리스트는 종주하는 동안 끝이 어딘지 알 수 없고, 찾았다 한들 되돌아갈 방법이 마땅치 않다.

- 당연히 다른 자료구조를 쓰는 것이 훨씬 낫지만 주어진 그대로 문제를 풀자.

- 면접관 입장에서는 기존 자료구조를 바꾸거나 자료구조에 액세스하는 메서드에 특별한 제약 조건을 가하지 않는 풀이를 원하고 있을 것이다.

- m개 원소만큼 떨어져 있는 두 원소를 따지는 코드는 꼭 자리가 한 칸 어긋나는 문제가 생기곤 하기 때문에 주의.

---

## 리스트 단층화

> 일반적인 이중 연결 리스트에서 시작하자. 이제 각 원소에 다음 원소(next)와 이전 원소(prev)를 가리키는 포인터 외에 또 다른 이중 연결 리스트를 가리키는 자식(child) 포인터가 들어 있을 수 있다고 하자. 이 자식 리스트에도 또 다른 자식 리스트가 있을 수 있어서 결과적으로 아래 그림에 나와 있는 것과 같은 다층형 자료구조를 이루게 된다.
>
> ![다층형 자료구조](https://user-images.githubusercontent.com/72548112/139167989-b82d97c3-acb4-44ae-add5-64ad8442d601.png)
>
> 이 리스트를 단층화(flatten)시켜서 모든 노드가 한 층까리 이중 연결 리스트 안에 들어가도록 만들자. 처음에 첫 번째 틍의 머리와 꼬리 포인터가 주어진다. 각 노드는 다음과 같이 정의되는 C 구조체로 이루어진다.
>
> ```
> typedef struct Node {
>   struct Node *next;
>   struct Node *prev;
>   struct Node *child;
>   int value;
> } Node;
> ```

- 몇 가지 알고리즘을 고려해보고 각 알고리즘을 쓸 때 노드가 어떤 순서로 배열되는지 따져보다.

- 층별로 배열, 배치하는 위치(tail or 부모 리스트 바로 뒤에)

---

## 리스트 단층화 해제

> 리스트 단층화를 해제하라. 자료구조를 flattenList로 전달하기 전의 원래 상태로 복구시켜야 한다.

- 뒤에서 앞으로(역순)으로 훑어보는 방법 / 앞에서 훑어보는 방법 / 재귀 호출

- 현재 노드에 자식이 있으면 자식을 이전 노드로부터 분리 후 자식에서 시작하는 결로 탐색, 없으면 다음 노드로 이동.

- 반드시 재귀 호출을 사용할 필요 없으니 반복문도 확인.

- 리스트 맨 뒤에서 시작해서 거꾸로 올라가면 부모를 만날 때마다 각 자식 리스트를 끊어내는 식으로 단층화를 해제하면, 앞방향으로 진행한 작업을 반복하는 경우에 생길 수 있는 문제를 피할 수 있다.

---

## 순환형 리스트와 비순환형 리스트

> 널로 종료되는 연결 리스트 또는 사이클로 연결되는 연결 리스트가 주어졌다고 하자
>
> ![acyclic link list](https://user-images.githubusercontent.com/72548112/139170939-d6105cea-6f06-4460-8d42-a72a4e0d9407.png) >![cyclic link list](https://user-images.githubusercontent.com/72548112/139170952-7b7c3317-9451-4055-87eb-43f6449d3589.png)
>
> 리스트의 head 포인터를 받아서 그 리스트가 순환형인지 비순환형인지를 알아내는 함수를 작성하라. 리스트가 비순환형이면 false, 순환형이면 true를 반환해야 한다. 리스트 자체를 변경시킬 수 없다.

- 두 리스트의 차이점은 끝부분에 있다.

- 비순환형은 끝부분을 쉽게 찾을 수 있지만 순환형은 그렇지 못하다.

- 순환형은 같은 노드를 가리키는 포인터가 두 개가 있다.  
  => 지나간 노드인지 파악하여 find

- 포인터가 2개라면 어떨까.

---

## 요약

- 단일 연결 리스트
- 이중 연결 리스트
- 원형 연결 리스트
- 리스트 head 갱신
- 맨 뒤에서 m번째 원소 찾기
- 리스트 원소 삭제 및 추가
