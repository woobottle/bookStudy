# Chapter 4. 프로그래밍 문제 접근법

### 절차

* '비교 연산자를 전혀 사용하지 않고 두 정수가 같은지 판단하는 함수를 만드시오' => 비트 연산자를 활용해보자
```js
let a = 5;
let b = 3;
a & b // 1

let a = 3;
let b = 3;
a & b // 3
```
비트 연산자는 둘다 1이여야 1 반납, 같은 숫자면 온전한 숫자값이 나올 것이다.

* 이미 전에 풀어봐서 아는 문제가 나오더라도 무턱대로 바로 답을 말해버리는 일은 없어야 한다.    각 단계를 차근차근히 밟아나가면서 각 단계를 해결하는 사고 과정을 정리해서 대답해야 한다. 중요한 것은 어떤 프로그래밍 퍼즐의 정답을 외워서 말하는 것이 아니라 그 밑에 깔려 있는 개념을 제대로 이해하고 있다는 것을 보여주는 것이기 때문이다.
  
### 문제 해결

##### 기본단계
1. 문제를 확실히 이해한다.
2. 일단 문제를 이해하고 나면 간단한 예를 시도해본다.
3. 문제 풀이에 사용할 알고리즘과 자료구조에 초점을 맞춘다.
4. 알고리즘과 구현 방법을 알아내고 나면 면접관에게 풀이를 설명한다.
5. 코딩을 할 때도 뭘 하고 있는지 설명한다.
6. 필요하다면 질문을 한다.
7. 코드를 완성하고 나면 바로 몇 가지 예를 시도해보고 맞는지 확인한다.
8. 모든 오류 및 특수 상황, 특히 경계 조건을 확인한다.

##### 문제를 풀다가 막히는 경우
이때 좌절하면 안된다. 포기하지 않고 접근하는 모습을 보여주어야 한다.   
* 예를 다시 따져본다.
* 다른 자료구조를 시도해본다.
* 언어에서 그리 많이 쓰이지 않는 기능 또는 고급 기능을 고려해보자.

코드가 너무 길어지고 있다면 뭔가 잘못됐다는 징조일 수 있다.  
면접에서 다루는 코딩 문제의 답은 대체로 짧은 편이다.  

### 풀이 분석
빅 오 분석 => 입력값의 개수에 따라 알고리즘이 수행되는 데 걸리는 시간을 바탕으로 알고리즘의 효율성을 평가하는 실행 시간 분석법.
##### 빅 오 분석

음이 아닌 수가 저장된 배열에서 최댓값을 구하는 간단한 함수를 생각해 보자.

```c++
int CompareToMax(int array[], int n) {
  int curMax, i;

  if (n <= 0) 
    return -1;
  
  currMax = array[0];

  for (i = 1; i < n; i++) {
    if (array[i] > currMax) {
      currMax = array[i];
    }
  }
  return curMax;
}
```

```c++
int CompareToAll(int array[], int n) {
  int i, j;
  bool isMax;

  if (n <= 0) 
    return -1;

  for (i = n - 1; i > 0; i--) {
    isMax = true;
    for (j = 0; j < n, j++){
      if (array[j] > array[i])
        isMax = false
    }
    if (isMax) break;
  }
  return array[i];
}
```

##### 빅 오 분석법을 적용하는 방법
1. 입력 값이 무엇인지 확인하고 어떤 것을 n으로 놓아야 할지 결정한다.
2. 알고리즘에서 수행해야 할 연산 횟수를 n의 식으로 표현한다.
3. 차수가 제일 높은 항만 남긴다.
4. 모든 상수 인수를 없앤다.

##### 메모리 용량 분석
면접관이 프로그램에서 쓰는 메모리의 용량을 물어보는 경우가 종종 있다.   
메모리 용량이 실행 시간 못지않게 중요한 경우도 있는데, 특히 임베디드 시스템처럼 제약이 많은 환경에서는 더 그렇다.    

### 요약
정확하고 완전한 답을 하기 위해 최선을 다해야 한다.   
문제를 풀 때는 면접관과 의사소통을 최대한 활발하게 하자. 문제를 분석하고 답을 코딩하는 각 단계에서 자신이 무슨 생각을 하고 있는지 면접관에게 알릴 수 있어야 한다.