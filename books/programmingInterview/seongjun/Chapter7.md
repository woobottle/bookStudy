
특정 문제 제거
단어 뒤집기

# 배열과 문자열

* 최악도 O n
* 중간 데이터 삭제, 추가는 느림 O n
* 동적인 자료구조가 아님, 미리 크기를 알고있어야함

### JAVA

* 객체로 정의되어있고, 배열에대한 레퍼런스와 배열 원소에대한 레퍼런스가 다름
* 언어에서 배열의 크기를 추적해줌
* 단순한 대입으로 복사 못하는건 똑같음, 대입연산
* 루프돌면서 복사하거나 해야함
* 배열 인덱스를 접근할 떄 마다 현재 크기하고 비교해서 경계를 벗어나면 예외를 던짐
  * 느려짐;
  * 확실히 경계 검사 필요 없으면 건너뜀

### JAVASCRIPT

* Array 객체의 인스턴스, 동적이고 자동으로 조절됨
* 쭉 연결되어 있는 메모리 블록에 저장되는게 보통이지만 반드시 그런건 아님

## 문자열

* 문자들이 연속적으로 나열되어있는데, 사용하는 언어와 운영체제에 따라 어떻게 구성되었는지가 크게 달라짐
* 각 글자가 한바이트씩으로 표현되는 시대는 갔다? 유니코드의 멀티바이트 인코딩을 써야한다..
* .... UTF-16은 16비트 char로 표현이고.,... UTF-8은 ASCII로 표현 가능 ...한바이트로 
* 가변 길이 인코딩을 쓰면 문자열 다루기가 훨씬 복잡해짐
* char 개수보다 문자열에 들어가는 문자 수가 적어질수도..
* 면접에선 가변 길이 인코딩은 잘 건드리지 않는다.

### Java

* String이라는 특별한 시스템 클래스의 객체임, 손쉽게 문자 및 바이트 배열과 상호변환 가능하지만 분명히 서로 다른 유형
* 자바의 char 크기는 2바이트
* 문자열에 있는 개별 문자는 직접 액세스 할수없고 String클래스의 메서드를 써야함
* 소스코드의 String 리터럴은 컴파일러에서 String 인스턴스로 변환해줌
* 검색, 변환, 개별 문자 추출, 공백 문자 잘라내는 기능하는 다양한 메서드 제공
* 문자열 변환 불가능 - 조작하는 메서드는 새로운 문자열 인스턴스 반환
* 변형 가능한 StringBuffer, StringBuilder도 있음 ( builder는 최근에 도입, 빠르지만 스레드세이프 X )

```java
String s ="";
for(int i=0; i< 10; ++i){
  s = s + i + "";
}

String s = "";
for(int i=0; i< 10; ++i){
  StringBuilder t = new StringBulilder();
  t.append(s);
  t.append(i);
  t.append("");
  s = t.toString();
}


StringBuilder b = new StringBulilder();
for(int i=0; i< 10; ++i){
  b.append(i);
  b.append("");
}
String s = b.toString();

```

### Javascript

자바스크립트에서도 String객체가 정의되어있음

일반적인 문자열 연산은 물론 문자열 매칭 및 치환을 위한 정규 표현식같은 고급 기능 제공

## 문제

## 반복되지 않는 첫 번째 문자 찾기

> 문자열에서 처음으로 반복되지 않는 문자를 효율적으로 찾아내는 함수를 작성하라. 예를들어 'total'에서 처음으로 등장하는 반복되지 않는 문자는 o이고, 'teeter'에서 처음으로 등장하는 반복되지 않는 문자는 'r'이다. 작성한 알고리즘의 효율에 대해 논하라

* 문자열을 다른 모든 문자와 비교해서 그 문자가 반복되는지 알 수 있ㅇ므 n^2임
* n이 각 문자를 문자열 내에 있는 다른 문자하고 비교하는 과정이 있어서 문제임
* 이 검색 효율을 개선하면 전체 효율을 향상 가능
* 이진트리에 넣고 쓰면 log(n) , 배열과 해시테이블에 넣으면 상수시간
* 등장 횟수를 저장하고 1돌면됨
* 해시는 배열에 비해 룩업 오버헤드가 좀 더 크다
* 배열은 처음에 임의의 값이 들어 있기 때문에 전부 0으로 설정하는 데 시간이 걸린다
* 해시 테이블은 처음에 아예 값이 없어서 0으로 설정하는 데 시간이 소모되지 않음
* 배열을 쓰려면 가능한 모든 문자 개수만큼 원소가 필요함, ASCII면 괜찮지만 UNICODE는 16비트 인코딩 기준으로 삼으면.... 65000개 이상의 원소
* 해시테이블을 쓰면 입력된 문자열에 들어 있는 서로 다른 문자 개수만큼 저장할 공간만 있으면 됨

```python
#대충코드
```

1. 모든 유니코드 문자가 하나의 16비트짜리 자바 char로 표현된다고 가정
   * 위의 함수에서는 문자열의 char를 하나씩 처리하므로 BMP외의 코드 포인트는 제대로 처리할 수 없다.
2. 자바 컬렉션 클래스는 레퍼런스 유형에 대해서만 쓸 수 있다. 
   * 어떤 키와 연관된 값을 증가시킬 때마다 이전 값을 저장하고 있던 Integer 객체는 버리고 증가된 값이 저장된 Integer를 새로 만들어야함
   * 한번도 안나오는 경우, 한번 나오는 경우, 두번이상 나오는 경우 이렇게 세경우만...
   * 따라서 두가지 경우만 처리하면 된다? 메모리측면에서..



## 특정 문자 제거

> 변형 가능한 ASCII 문자열에서 문자를 삭제하는 효율적인 함수를 작성하라
>
> 이 함수에서 str과 remove라는 두 인자를 받아들인다.
>
> remove에 들어있는 모든 문자를 str에서 제거해야한다.

* 문자를 찾고, 삭제해야함
* 삭제면? 재배치해야함, 밀어서 옮기고 문자열 크기를 줄여야함
* 매번 삭제할때마다 남아 있는 문자를 뒤로 한 위치씩 밀어야함 
* str이 n이면 최악 n^2 ( n -1, n -2 , ... )
* 임시 문자열 버퍼를 할당하고 고친 문자열을 거기에 저장?, 다시 str로 복사?
* 최대 문자를 두번만 옮기므로 삭제연산 O(n), 
* 하지만 원본 문자열과 같은 크기의 임시버퍼, 메모리 오버헤드
* 문자열 복사 오버헤드
* 문자열 지나가면서 덮어씌운다? 임시버퍼 안쓰고??..

* remove 각각 찾아서 지우는거 mn임
* 주어진 문자가 remove에 들어있는지 판단하는거를 O(m)보다 빨리 가능함

1. 해시테이블 - remove에 있는 문자를 훑으면서 배열에 그 문자에 해당하는 값을 true로 설정 - 배열에...
2. 출발지와 목적지 인덱스를 써서 str을 훑어 나가면서 룩업 배열에서 그 문자에 해당하는 값이 false인 경우에만 문자를 복사
3. 이미 제거한 문자에 맞춰서 str 길이 설정

O(M + N) 임 ~

## 단어 뒤집기

> 한 문자열에 들어 있는 단어의 순서를 뒤집는 함수를 작성하라, 모든 단어는 스페이스로구분, 문장 부호는 글자와 같은것으로 구분

* 간단한 접근법은 스캐너를 써서 단어를 식별하고 그 단어를 임시 버퍼에 저장했다가 다시 원본 문자열로 복사

* 뒤에서부터 서치한다 치면 첫 문자 발견 시 뒤집히지 않은 순서로 버퍼에 넣는다.

* 문자열을 다 뒤집어놓고 다시 복구시키는 방법도 있음

  