# 3장. 함수

- 이해하기 쉬운 이유는 무엇일까?
- 어떻게 해야 의도를 분명히 표현하는 함수를 구현할 수 있을까?
- 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

## 작게 만들어라!

- 작게? → 짧게! (가로로! 세로로!)

    짧은 함수가 명확히다.

    각 함수가 이야기 하나를 표현했다.

    ### 블록과 들여쓰기

    - if, else, while 문 등에 들어가는 블록은 한 줄이어야 한다.
    - Enclosing Function이 작아질 뿐 아니라
    블록 안의 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.
    - 중첩 구조가 생길만큼 함수가 커지면 안 된다.

    ### 한 가지만 해라!

    - "함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다."
    - 그렇다면 그 한 가지의 기준은?
    → 추상화 수준이 1개라는 것.
    - 함수를 만드는 이유는 큰 개념(함수 이름)을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서.
    - 또 다른 기준
    → 의미 있는 이름을 가진 다른 함수를 추출할 수 있는가?

## 함수 당 추상화 수준은 하나로!

- 함수가 확실히 "한 가지" 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

    ```jsx
    getHtml() // 높은 수준
    String pagePathName = PathParser.render(pagepath) // 중간 수준
    .append("\n") // 낮은 수준
    ```

- 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
→ 특정 표현이 근본 개념인지 or 세부사항인지 구분하기 어렵기 때문.
→ 개어진 창문처럼 사람들이 함수에 세부사항을 더 추가하기 때문. → 싹을 뽑아야 함.

    ### 내려가기 규칙 (위에서 아래로 읽기)

    - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
    → 자연스럽게 단계단계 낮아지는 이점.

    "추상화 수준이 하나인 함수를 구현하기란 쉽지 않다. 많은 프로그래머가 곤란을 겪는다.

    그렇지만 매우 중요한 규칙이다.

    핵심은 짧으면서도 '한 가지'만 하는 함수다.

    내려가기 규칙을 준수하면 추상화 수준을 일관되게 유지하기가 쉬워진다."

## Switch 문

- polymorphism(다형성)을 이용
→ 저차원 클래스에 숨기고 절대로 반복하지 않는 방법

[단일 책임 원칙 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%B1%85%EC%9E%84_%EC%9B%90%EC%B9%99)

[개방-폐쇄 원칙 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99)

- 필자는 switch 문을 단 한 번만 참아준다. (다형적 객체를 생성하는 코드 안에서.)
- 물론 불가피한 상황도 생길 수 있다. 그.치.만.

## 서술적인 이름을 사용하라!

- 좋은 이름이 주는 가치는 아무리 강조해도 지나치지 않다.
- 함수가 단순할수록 서술적인 이름을 고르기도 쉬워진다.
- 이름은 길어도 괜찮다.
- 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.
그 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.
- 일관성이 있어야 한다.

## 함수 인수

- 인수는 개념을 이해하기 어렵게 만든다.
- 최선은 입력 인수가 없는 경우(무항)이며, 차선은 1개뿐인 경우다.

    ### 많이 쓰는 단항 형식

    - 질문을 던지는 경우

        ```jsx
        boolean fileExists("MyFile")
        ```

    - 인수를 변환해 결과를 반환하는 경우
    - 이벤트로 사용하는 경우
    → 이벤트라는 사실이 코드에 명확히 드러나야 한다.

    - 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.
    - 입력 함수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.

    ### 플래그 인수

    - 함수로 부울 값을 넘기는 "관례"는 정말로 끔찍하고 추하다.

    ### 이항 함수

    - 어떤 코드든 절대로 무시하면 안 된다.

        "무시한 코드에 오류가 숨어든다."

    - 자연적인 순서를 지켜라.

    ### 삼항 함수

    - 이항 함수보다 "순서, 주춤, 무시"로 야기되는 문제가 2배 이상 늘어난다.

    ### 인수 객체

    - 인수가 2-3개 필요하다면 독자적인 클래스 변수로 선안할 가능성을 짚어보아라.

        ```jsx
        Circle makeCircle(double x, double y, double radius);
        Circle makeCircle(Point center, double radius); // 변환
        ```

    - 눈속임이라 여겨질지 모르지만 그렇지 않다.

    ### 인수 목록

    - 인수 개수가 가변적인 함수도 필요.

        ```jsx
        String.format("%s worked %.2f hours.", name, hours);
        ```

    - 가변 인수 전부를 동등하게 취급하면 List 형 인수 하나로 취급할 수 있다.
    - 가변 인수도 동일하게 삼항 함수를 넘어선다면 문제가 있다.

    ### 동사와 키워드

    - 함수의 의도나 "인수의 순서와 의도"를 제대로 표현하기 위해선 좋은 함수 이름은 필수.
    - 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.

        ```jsx
        write(name) // 또는
        writeField(name)
        ```

    - 함수 이름에 키워드를 추가할 수도 있다.

        ```jsx
        assertEquals(expected, actual) // 보다
        assertExpectedEqualsActual(expected, actual) // 더 좋다
        ```

## 부수 효과를 일으키지 마라

- 예상치 못하게 클래스 변수를 수정하거나 인수, 시스템 전역 변수를 수정하는 것은
교활하고 해로운 거짓말이다.
- Temporal Coupling(시간적인 결합) 이나 Order Dependency(순서 종속성)를 초래한다.

    ⇒ 우리는 동시성을 허용할 필요가 있고, 시간이나 순서에 따른 의존성의 결합을 끊는 방법을 생각할 필요가 있다.

    ⇒ "B를 할 수 있을 때만 A를 실행시킬 수 있다." 라는 것

### 출력 인수

- 함수 선언부를 찾아보는 행위는 인지적으로 거실린다는 뜻이므로 피해야 한다.
- 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다.
- 출력 인수로 사용하라고 설계한 변수가 "this"이기 때문.

    ```jsx
    appendFooter(s); // 보다
    report.appendFooter()
    ```

- 일반적으로 출력 인수는 피해야 한다.

## 명령과 조회를 분리하라

- 함수는 "수행"이나 "답"하는 것 중 하나만 해야 한다.

    ```jsx
    if (set("username", "unclebob")) ...
    // username이 unclebob으로 설정되어 있는지 확인하는 코드인가?
    // 아님 설정하는 코드인가?

    if (attributeExists("username")) {
    	setAttribute("username", "unclebob");
    	...
    }
    ```

## 오류 코드보다 예외를 사용하라

- 오류 코드를 반환하는 방식은 "명령/조회" 분리 규칙을 미묘하게 위반한다.

    ```jsx
    if (deletePage(page) = E_OK)
    ```

    ⇒ 위 코드는 여러 단계로 중첩될 수 있는 위험성을 지니고 있다.

    ### Try / Catch 블록 뽑아내기

    - Try 블록은 코드 구조에 혼락을 일으키기 째문에 별도 함수로 뽑아내는 편이 좋다.
    - 오류 처리도 한 가지 작업이다

    ### [Error.java](http://error.java) 의존성 자석

    ```jsx
    public enum Error {
    	OK,
    	INVALID,
    	NO_SUCH,
    	...
    }
    ```

    - 위와 같은 클래스는 다른 클래스에서 Error enum을  "import"해 사용해야 하므로 "의존성 자석"이다.
    - 오류 코드 대신 예외를 사용하면 재컴파일/재배치 없이도 새 예외 클래스를 추가할 수 있다.

## 반복하지 마라 (DRY)

- 어쩌면 중복은 소프트웨어에서 모든 악의 근원이다.
- 모든 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다.

## 구조적 프로그래밍

- 함수가 아주 클 때에는 단일 입/출구 규칙을 지켜라
- 함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다.

## 함수를 어떻게 짜는지

- 소프트웨어를 짜는 행위는 글짓기와 비슷.
- 처음에는 길고 복잡하다.
들여쓰기 단계도 많고 중복된 루프도 많다.
인수 목록도 아주 길다.
이름은 즉흥적이고 코드는 중복된다.
- 그러나, 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스도 만든다.
그런 다음 리펙토링을 통해 이 장에서 설명한 규칙을 따르는 함수가 얻어진다.
- 처음부터 탁 짜내지 않는다. 그게 가능한 사람은 없으리라.

## 결론

- 함수는 그 언어에서 동사며, 클래스는 명사다.
- 프로그래밍의 기술은 언제나 언어 설계의 기술이다. 예전에도 그랬고 지금도 마찬가지다.

- master 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다.
- 프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어 이야기를 풀어간다.

- 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심하기 바란다.
- 여러분이 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아떨어져야 이야기를 풀어가기가 쉬워진다는 사실을 기억하기 바란다.