# Chapter.9 UnitTests

[[기술면접] TDD(Test-Driven-Development) 방법론에 대해서](https://wooaoe.tistory.com/33)

- 애자일과 TDD 덕택에 단위 테스트를 자동화하는 프로그래머들이 이미 많아졌으며 점점 더 늘어나는 추세다.
- 하지만 제대로 된 테스트 케이스를 작성해야 한다는 좀 더 미묘한 사실을 놓쳐버렸다.

## TDD 법칙 세 가지

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통화할 정도로만 실제 코드를 작성한다.
- 이렇게 일하면 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나오지만 이런 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.

## 깨끗한 테스트 코드 유지하기

- 실제 코드가 진화하면 테스트 코드도 변해야 한다.
- 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸린다.

- 테스트 슈트가 없으면 이쪽을 수정해도 저쪽이 안전하다는 사실을 검증하지 못한다.
⇒ 결함율이 높아지기 시작한다.
⇒ 변경을 주저한다.
⇒ 득보다 해가 크다 생각해 코드를 정리하지 않는다.
⇒ 망

- 테스트 코드를 깨끗하게 짰다면 테스트에 쏟아 부은 노력은 허사로 돌아가지 않았을 터.
- 테스트 코드는 실제 코드 못지 않게 중요하다.

### 테스트는 유연성, 유지보수성, 재사용성을 제공한다.

- 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 "단위 테스트"다.
- 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다.

## 깨끗한 테스트 코드

- 가독성, 가독성, 가독성

    ⇒ 명로성, 단순성, 풍부한 표현력.

- 테스트 코드는 최소의 표현으로 많은 것을 나타내야함.
- Build-Operate-Check 패턴
    - Build: 테스트 자료 생성
    - Operate: 테스트 자료 조작
    - Check: 조작한 결과 확인
- 테스트 코드는 본론에 돌입해 필요한 자료 유형과 함수만 사용하기에 온갖 잡다하고 세세한 코드에 주눅들고 헷갈릴 필요 없이 재빨리 이해할 수 있다.

### 이중 표준

- 실제 환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식

    (대개 메모리나 CPU 효율과 관련 있는 경우)

- 코드의 깨끗함과는 철저히 무관하다.

## 테스트 당 assert 하나

- given - when - then 관례 ⇒ 읽기가 쉬워진다.
- 테스트를 분리하면 중복되는 코드가 많아진다.
- TEMPLATE METHOD 패턴
    - 변하지 않는 기능 ⇒ 슈퍼 클래스
    - 자주 변경되며 확장할 기능 ⇒ 서브클래스
- 하지만 때로는 주저 없이 함수 하나에 여러 assert 문을 넣기도 한다. 단지 assert 문 개수는 최대한 줄여야.

### 테스트 당 개념 하나

## F.I.R.S.T

- Fast: 테스트는 빨리 돌아야 한다.
- Independent: 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다.
- Repeatable: 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.
- Self-Validating: 결과는 반드시 성공 or 실패. 그렇지 않는다면 판단은 주관적이 되기 때문
- Timely: 실제 코드를 구현하기 "직전"에 구현한다.

## 결론

- 테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요.
- 테스트 코드는 지속적으로 깨끗하게 관리하자.
- 표현력을 높이고 간결하게 정리하자.
- 테스트 API를 구현해 DSL를 만들자

오우 노우...